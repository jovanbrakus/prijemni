<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Odnos povrsina lopte i kocke</title>
<script>
MathJax = {
  tex: {
    inlineMath: [['\\(', '\\)'], ['$', '$']],
    displayMath: [['\\[', '\\]']]
  },
  svg: { fontCache: 'global' }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
<script type="text/info" id="logic-scratchpad">
Problem: Lopta je upisana u kocku. Odnos površina lopte i kocke je?

Step 1: Define the cube
  Let the cube have side length a.
  Surface area of cube: S_cube = 6a^2 (6 faces, each a^2)

Step 2: Find the inscribed sphere
  A sphere inscribed in a cube touches all 6 faces at their centers.
  The sphere's diameter equals the cube's side length: d = a
  Therefore, radius r = a/2

Step 3: Surface area of sphere
  S_sphere = 4*pi*r^2 = 4*pi*(a/2)^2 = 4*pi*a^2/4 = pi*a^2

Step 4: Compute the ratio
  S_sphere / S_cube = pi*a^2 / (6a^2) = pi/6

Answer: (B) pi/6
</script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0f172a;
  color: #e2e8f0;
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  line-height: 1.7;
  padding: 20px;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

h1 {
  font-size: 2.2rem;
  font-weight: 800;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 8px;
  line-height: 1.3;
}

.subtitle {
  color: #94a3b8;
  font-size: 1.1rem;
  margin-bottom: 30px;
}

.card {
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 14px;
  padding: 24px;
  margin-bottom: 24px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.35);
}

.card h2 {
  color: #60a5fa;
  font-size: 1.4rem;
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.card h3 {
  color: #e2e8f0;
  font-size: 1.15rem;
  margin-bottom: 10px;
}

.highlight {
  color: #f472b6;
  font-weight: 600;
}

.math-box {
  background: rgba(56,189,248,0.08);
  border: 1px solid rgba(56,189,248,0.15);
  border-radius: 10px;
  padding: 16px 20px;
  margin: 12px 0;
  font-family: 'Courier New', monospace;
  overflow-x: auto;
}

.given-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 14px;
}

.given-item {
  background: rgba(96,165,250,0.08);
  border: 1px solid rgba(96,165,250,0.15);
  border-radius: 10px;
  padding: 12px 18px;
  min-width: 120px;
  text-align: center;
}

.given-item .label {
  color: #94a3b8;
  font-size: 0.85rem;
  margin-bottom: 4px;
}

.given-item .value {
  color: #60a5fa;
  font-size: 1.15rem;
  font-weight: 700;
}

.plan-card {
  border-left: 4px solid #a78bfa;
}

.plan-card h2 { color: #a78bfa; }

details {
  margin: 15px 0;
}

details summary {
  cursor: pointer;
  color: #60a5fa;
  font-weight: 600;
  padding: 10px 14px;
  background: rgba(96,165,250,0.06);
  border-radius: 8px;
  border: 1px solid rgba(96,165,250,0.12);
  list-style: none;
  user-select: none;
}

details summary::-webkit-details-marker { display: none; }

details summary::before {
  content: '\25B8 ';
  display: inline;
}

details[open] summary::before {
  content: '\25BE ';
}

details .details-content {
  padding: 14px 18px;
  margin-top: 8px;
  background: rgba(96,165,250,0.04);
  border-radius: 8px;
  border: 1px solid rgba(96,165,250,0.08);
}

.step-container {
  display: flex;
  gap: 16px;
  margin-bottom: 20px;
  align-items: flex-start;
}

.step-badge {
  min-width: 34px;
  height: 34px;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  font-size: 0.95rem;
  color: #0f172a;
  margin-top: 2px;
  flex-shrink: 0;
}

.step-content {
  flex: 1;
  min-width: 0;
}

.step-content h3 {
  margin-bottom: 8px;
}

.insight-box {
  background: linear-gradient(135deg, rgba(96,165,250,0.12), rgba(167,139,250,0.12));
  border: 1px solid rgba(167,139,250,0.3);
  border-radius: 14px;
  padding: 22px 26px;
  margin-bottom: 24px;
}

.insight-box h2 { color: #a78bfa; }

.final-answer-box {
  background: linear-gradient(135deg, rgba(52,211,153,0.1), rgba(74,222,128,0.08));
  border: 2px solid rgba(52,211,153,0.35);
  border-radius: 16px;
  padding: 28px;
  text-align: center;
  margin-bottom: 24px;
}

.final-answer-box .answer-value {
  font-size: 2.4rem;
  font-weight: 800;
  color: #4ade80;
  margin: 16px 0;
}

.options-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
  margin: 18px 0;
}

.option-chip {
  background: rgba(96,165,250,0.08);
  border: 1px solid #334155;
  border-radius: 10px;
  padding: 10px 22px;
  font-size: 1.05rem;
  color: #94a3b8;
  transition: all 0.2s;
}

.option-chip.correct {
  background: rgba(52,211,153,0.15);
  border-color: #34d399;
  color: #4ade80;
  font-weight: 700;
  box-shadow: 0 0 20px rgba(52,211,153,0.15);
}

.pitfall-box {
  border-left: 4px solid #e09468;
}

.pitfall-box h2 { color: #e09468; }

.challenge-box {
  border-left: 4px solid #a78bfa;
}

.challenge-box h2 { color: #a78bfa; }

.canvas-wrapper {
  background: #0c1222;
  border-radius: 12px;
  border: 1px solid #334155;
  overflow: hidden;
  margin: 14px 0;
}

canvas {
  width: 100%;
  display: block;
  touch-action: none;
}

.provera-note {
  color: #94a3b8;
  font-size: 0.95rem;
  margin-top: 12px;
  padding: 12px 16px;
  background: rgba(52,211,153,0.05);
  border-radius: 8px;
  border: 1px solid rgba(52,211,153,0.12);
}

.formula-list {
  list-style: none;
  padding: 0;
}

.formula-list li {
  padding: 8px 0;
  border-bottom: 1px solid rgba(51,65,85,0.5);
}

.formula-list li:last-child { border-bottom: none; }

.canvas-controls {
  display: flex;
  gap: 12px;
  align-items: center;
  justify-content: center;
  margin-top: 10px;
  flex-wrap: wrap;
}

.canvas-controls label {
  color: #94a3b8;
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
}

.canvas-controls input[type="checkbox"] {
  accent-color: #60a5fa;
  width: 16px;
  height: 16px;
}

.canvas-controls input[type="range"] {
  accent-color: #60a5fa;
  width: 120px;
}

.canvas-hint {
  color: #64748b;
  font-size: 0.85rem;
  text-align: center;
  margin-top: 6px;
}

@media (max-width: 700px) {
  h1 { font-size: 1.6rem; }
  .card { padding: 16px; }
  .step-container { flex-direction: column; gap: 8px; }
  .given-grid { flex-direction: column; }
  .options-grid { flex-direction: column; align-items: center; }
  .final-answer-box .answer-value { font-size: 1.8rem; }
}
</style>
</head>
<body>

<div class="container">

  <!-- Title -->
  <h1>Odnos povrsina lopte i kocke</h1>
  <p class="subtitle">Stereometrija: upisana lopta u kocku i odnos njihovih povrsina</p>

  <!-- Problem Statement -->
  <div class="card">
    <h2>Postavka zadatka</h2>
    <p>Lopta je upisana u kocku. Odnos povrsina lopte i kocke je:</p>
    <div class="given-grid">
      <div class="given-item">
        <div class="label">Odgovor (A)</div>
        <div class="value">\(\dfrac{2\pi}{3}\)</div>
      </div>
      <div class="given-item">
        <div class="label">Odgovor (B)</div>
        <div class="value">\(\dfrac{\pi}{6}\)</div>
      </div>
      <div class="given-item">
        <div class="label">Odgovor (C)</div>
        <div class="value">\(\dfrac{4\pi}{3}\)</div>
      </div>
      <div class="given-item">
        <div class="label">Odgovor (D)</div>
        <div class="value">\(\dfrac{\pi}{12}\)</div>
      </div>
      <div class="given-item">
        <div class="label">Odgovor (E)</div>
        <div class="value">\(\dfrac{8\pi}{3}\)</div>
      </div>
    </div>
  </div>

  <!-- Plan -->
  <div class="card plan-card">
    <h2>Plan resavanja</h2>
    <p>Neka je stranica kocke \(a\). Odredimo poluprecnik upisane lopte, zatim izracunamo povrsinu
       lopte i povrsinu kocke, i na kraju nadjemo njihov odnos. Kljucna cinjenica je da precnik
       upisane lopte odgovara stranici kocke.</p>
  </div>

  <!-- Theory Refresher -->
  <div class="card">
    <details>
      <summary>Kljucne formule i teoreme</summary>
      <div class="details-content">
        <ul class="formula-list">
          <li>Povrsina lopte poluprecnika \(r\): \(P_{\text{lopte}} = 4\pi r^2\)</li>
          <li>Povrsina kocke stranice \(a\): \(P_{\text{kocke}} = 6a^2\) (6 kvadratnih strana)</li>
          <li>Lopta upisana u kocku dodiruje svih 6 strana u njihovim centrima</li>
          <li>Precnik upisane lopte jednak je stranici kocke: \(d = a\), tj. \(r = \dfrac{a}{2}\)</li>
          <li>Zapremina lopte: \(V = \dfrac{4}{3}\pi r^3\) (korisno za bonus izazov)</li>
        </ul>
      </div>
    </details>
  </div>

  <!-- Visual Aid -->
  <div class="card">
    <h2>Vizuelni prikaz</h2>
    <p style="color: #94a3b8; margin-bottom: 10px;">Interaktivna 3D vizualizacija lopte upisane u kocku. Prevlacite da rotirate, koristite kontrole ispod.</p>
    <div class="canvas-wrapper">
      <canvas id="diagram" width="800" height="520"></canvas>
    </div>
    <div class="canvas-controls">
      <label><input type="checkbox" id="showSphere" checked> Lopta</label>
      <label><input type="checkbox" id="showCube" checked> Kocka</label>
      <label><input type="checkbox" id="showRadius" checked> Poluprecnik</label>
      <label><input type="checkbox" id="showLabels" checked> Oznake</label>
      <label>Rotacija: <input type="range" id="rotSpeed" min="0" max="100" value="30"></label>
    </div>
    <p class="canvas-hint">Prevlacite misem ili prstom da rotirate model</p>
  </div>

  <!-- Step-by-step Solution -->
  <div class="card">
    <h2>Resenje korak po korak</h2>

    <!-- Step 1 -->
    <div class="step-container">
      <div class="step-badge">1</div>
      <div class="step-content">
        <h3>Uvedimo oznake</h3>
        <p>Neka je stranica kocke \(a\). Kocka ima 6 kvadratnih strana, svaka povrsine \(a^2\).</p>
        <div class="math-box">
          \[
          P_{\text{kocke}} = 6a^2
          \]
        </div>
      </div>
    </div>

    <!-- Step 2 -->
    <div class="step-container">
      <div class="step-badge">2</div>
      <div class="step-content">
        <h3>Odredimo poluprecnik upisane lopte</h3>
        <p>Kada je lopta <span class="highlight">upisana</span> u kocku, ona dodiruje svaku od 6 strana
           kocke tacno u centru te strane. Rastojanje od centra kocke do svake strane jednako je
           poluprecniku lopte.</p>
        <p>Posto je rastojanje od centra kocke do sredista bilo koje strane jednako polovini stranice:</p>
        <div class="math-box">
          \[
          r = \frac{a}{2}
          \]
        </div>
        <p>Drugim recima, precnik lopte je jednak stranici kocke: \(d = 2r = a\).</p>
      </div>
    </div>

    <!-- Checkpoint 1 -->
    <details>
      <summary>Proveri se: Zasto precnik lopte mora biti jednak stranici kocke?</summary>
      <div class="details-content">
        <p>Zamislimo presek kocke i lopte ravni koja prolazi kroz centar kocke i paralelna je sa
           jednim parom naspramnih strana. Dobijamo kvadrat stranice \(a\) i krug koji dodiruje
           sve 4 strane tog kvadrata. U tom preseku, precnik kruga je jednak stranici kvadrata,
           tj. \(d = a\). Isto vazi i u svakom drugom pravcu, jer je lopta simetricna.</p>
      </div>
    </details>

    <!-- Step 3 -->
    <div class="step-container">
      <div class="step-badge">3</div>
      <div class="step-content">
        <h3>Izracunajmo povrsinu lopte</h3>
        <p>Koristimo formulu za povrsinu lopte \(P = 4\pi r^2\) i uvrstimo \(r = \dfrac{a}{2}\):</p>
        <div class="math-box">
          \[
          P_{\text{lopte}} = 4\pi r^2 = 4\pi \left(\frac{a}{2}\right)^2 = 4\pi \cdot \frac{a^2}{4} = \pi a^2
          \]
        </div>
        <p>Dakle, povrsina upisane lopte je tacno \(\pi a^2\).</p>
      </div>
    </div>

    <!-- Checkpoint 2 -->
    <details>
      <summary>Proveri se: Da li je logicno da povrsina lopte iznosi \(\pi a^2\)?</summary>
      <div class="details-content">
        <p>Provera dimenzija: \(\pi a^2\) ima dimenziju povrsine (kvadrat duzine) &mdash; tacno.
           Numericka provera za \(a = 2\): \(r = 1\), pa \(P_{\text{lopte}} = 4\pi \approx 12{,}57\).
           Formula daje \(\pi \cdot 4 = 4\pi \approx 12{,}57\). Sve se slaze!</p>
      </div>
    </details>

    <!-- Step 4 -->
    <div class="step-container">
      <div class="step-badge">4</div>
      <div class="step-content">
        <h3>Izracunajmo odnos povrsina</h3>
        <p>Sada delimo povrsinu lopte sa povrsinom kocke:</p>
        <div class="math-box">
          \[
          \frac{P_{\text{lopte}}}{P_{\text{kocke}}} = \frac{\pi a^2}{6a^2} = \frac{\pi}{6}
          \]
        </div>
        <p>Primetimo da se \(a^2\) skracuje &mdash; odnos <span class="highlight">ne zavisi od velicine kocke</span>,
           vec je uvek konstantan i jednak \(\dfrac{\pi}{6}\).</p>
      </div>
    </div>

    <!-- Checkpoint 3 -->
    <details>
      <summary>Proveri se: Numericka verifikacija</summary>
      <div class="details-content">
        <p>Za \(a = 10\):</p>
        <div class="math-box">
          \[
          P_{\text{lopte}} = \pi \cdot 100 = 100\pi \approx 314{,}16
          \]
          \[
          P_{\text{kocke}} = 6 \cdot 100 = 600
          \]
          \[
          \frac{314{,}16}{600} \approx 0{,}5236
          \]
          \[
          \frac{\pi}{6} \approx 0{,}5236 \quad \checkmark
          \]
        </div>
      </div>
    </details>
  </div>

  <!-- Key Insight -->
  <div class="insight-box">
    <h2>Kljucni uvid</h2>
    <p>Odnos povrsina upisane lopte i kocke je <span class="highlight">univerzalna konstanta</span> &mdash;
       ne zavisi od velicine kocke. To je zato sto su oba tela slicna (skaliraju se sa \(a^2\)),
       pa se pri deljenju faktor \(a^2\) ponisti. Ovaj odnos \(\dfrac{\pi}{6} \approx 0{,}524\)
       znaci da lopta pokriva oko 52,4% povrsine kocke &mdash; vise od polovine, sto je intuitivno
       smisleno kada zamislimo koliki deo svake strane kocke lopta "pokriva".</p>
  </div>

  <!-- Final Answer -->
  <div class="final-answer-box">
    <h2 style="color: #34d399; margin-bottom: 10px;">Konacan odgovor</h2>
    <div class="options-grid">
      <div class="option-chip">(A) \(\dfrac{2\pi}{3}\)</div>
      <div class="option-chip correct">(B) \(\dfrac{\pi}{6}\)</div>
      <div class="option-chip">(C) \(\dfrac{4\pi}{3}\)</div>
      <div class="option-chip">(D) \(\dfrac{\pi}{12}\)</div>
      <div class="option-chip">(E) \(\dfrac{8\pi}{3}\)</div>
    </div>
    <div class="answer-value">\(\displaystyle \frac{P_{\text{lopte}}}{P_{\text{kocke}}} = \frac{\pi}{6}\)</div>
    <p style="color:#4ade80; font-size:1.2rem; font-weight:700;">Odgovor je (B)</p>
    <div class="provera-note">
      <strong>Provera:</strong> Za proizvoljan \(a\), \(P_{\text{lopte}} = \pi a^2\) i
      \(P_{\text{kocke}} = 6a^2\), pa je odnos uvek \(\pi/6 \approx 0{,}5236\).
      Rezultat ne zavisi od velicine kocke.
    </div>
  </div>

  <!-- Common Pitfalls -->
  <div class="card pitfall-box">
    <h2>Ceste greske</h2>
    <ul style="list-style: disc; padding-left: 20px; color: #e2e8f0;">
      <li style="margin-bottom: 10px;"><strong>Zamena upisane i opisane lopte:</strong> Ako bi lopta bila
        <em>opisana</em> oko kocke (prolazi kroz temena), njen poluprecnik bi bio
        \(R = \frac{a\sqrt{3}}{2}\), sto daje potpuno drugaciji odnos. Ovde je lopta
        <em>upisana</em>, tj. dodiruje strane.</li>
      <li style="margin-bottom: 10px;"><strong>Greska sa formulom za povrsinu lopte:</strong> Cesta zamka je
        koristiti \(P = \pi r^2\) (formula za povrsinu kruga) umesto \(P = 4\pi r^2\)
        (formula za povrsinu lopte). To bi dalo odgovor \(\pi/24\), sto nije ponudjeno.</li>
      <li><strong>Mesanje precnika i poluprecnika:</strong> Ako se uzme \(r = a\) umesto
        \(r = a/2\), dobija se \(P_{\text{lopte}} = 4\pi a^2\), pa odnos \(2\pi/3\) &mdash;
        sto je odgovor (A), ali je pogresno.</li>
    </ul>
  </div>

  <!-- Optional Challenge -->
  <div class="card challenge-box">
    <h2>Bonus izazov</h2>
    <p>Ako je lopta upisana u kocku, koliki je odnos njihovih <em>zapremina</em>?</p>
    <div class="math-box">
      \[
      \frac{V_{\text{lopte}}}{V_{\text{kocke}}} = \; ?
      \]
    </div>
    <details>
      <summary>Pogledaj nagoveštaj</summary>
      <div class="details-content">
        <p>Zapremina lopte je \(V = \frac{4}{3}\pi r^3\), a zapremina kocke je \(V = a^3\).
           Za \(r = \frac{a}{2}\):</p>
        <div class="math-box">
          \[
          V_{\text{lopte}} = \frac{4}{3}\pi \left(\frac{a}{2}\right)^3 = \frac{4}{3}\pi \cdot \frac{a^3}{8} = \frac{\pi a^3}{6}
          \]
          \[
          \frac{V_{\text{lopte}}}{V_{\text{kocke}}} = \frac{\pi a^3 / 6}{a^3} = \frac{\pi}{6}
          \]
        </div>
        <p>Zanimljivo &mdash; odnos zapremina je takodje \(\dfrac{\pi}{6}\), isti kao odnos povrsina!
           Ovo je lepa posledica cinjenice da za upisanu loptu u kocku oba odnosa zavise od iste
           geometrijske veze \(r = a/2\).</p>
      </div>
    </details>
  </div>

</div>

<script>
(() => {
  const canvas = document.getElementById('diagram');
  const ctx = canvas.getContext('2d');

  // Controls
  const showSphereEl = document.getElementById('showSphere');
  const showCubeEl = document.getElementById('showCube');
  const showRadiusEl = document.getElementById('showRadius');
  const showLabelsEl = document.getElementById('showLabels');
  const rotSpeedEl = document.getElementById('rotSpeed');

  // Rotation state
  let angleX = -0.45;
  let angleY = 0.65;
  let autoRotate = true;
  let dragging = false;
  let lastX = 0, lastY = 0;
  let autoAngle = 0;

  // Touch / mouse drag
  function onPointerDown(e) {
    dragging = true;
    autoRotate = false;
    const pt = e.touches ? e.touches[0] : e;
    lastX = pt.clientX;
    lastY = pt.clientY;
  }
  function onPointerMove(e) {
    if (!dragging) return;
    e.preventDefault();
    const pt = e.touches ? e.touches[0] : e;
    const dx = pt.clientX - lastX;
    const dy = pt.clientY - lastY;
    angleY += dx * 0.008;
    angleX += dy * 0.008;
    angleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, angleX));
    lastX = pt.clientX;
    lastY = pt.clientY;
  }
  function onPointerUp() {
    dragging = false;
  }

  canvas.addEventListener('mousedown', onPointerDown);
  canvas.addEventListener('mousemove', onPointerMove);
  canvas.addEventListener('mouseup', onPointerUp);
  canvas.addEventListener('mouseleave', onPointerUp);
  canvas.addEventListener('touchstart', onPointerDown, { passive: false });
  canvas.addEventListener('touchmove', onPointerMove, { passive: false });
  canvas.addEventListener('touchend', onPointerUp);

  // 3D math helpers
  function rotateY(p, a) {
    const c = Math.cos(a), s = Math.sin(a);
    return [c * p[0] + s * p[2], p[1], -s * p[0] + c * p[2]];
  }
  function rotateX(p, a) {
    const c = Math.cos(a), s = Math.sin(a);
    return [p[0], c * p[1] - s * p[2], s * p[1] + c * p[2]];
  }
  function project(p, cx, cy, scale, fov) {
    const z = p[2] + fov;
    const f = fov / z;
    return [cx + p[0] * scale * f, cy - p[1] * scale * f, z];
  }

  // Cube vertices (unit cube centered at origin, side = 2)
  const cubeVerts = [];
  for (let i = 0; i < 8; i++) {
    cubeVerts.push([
      (i & 1) ? 1 : -1,
      (i & 2) ? 1 : -1,
      (i & 4) ? 1 : -1
    ]);
  }
  // Cube edges (pairs of vertex indices)
  const cubeEdges = [
    [0,1],[2,3],[4,5],[6,7], // x-edges
    [0,2],[1,3],[4,6],[5,7], // y-edges
    [0,4],[1,5],[2,6],[3,7]  // z-edges
  ];
  // Cube faces (for sorting)
  const cubeFaces = [
    { verts: [0,1,3,2], normal: [0,0,-1] }, // front
    { verts: [4,5,7,6], normal: [0,0,1] },  // back
    { verts: [0,1,5,4], normal: [0,-1,0] }, // bottom
    { verts: [2,3,7,6], normal: [0,1,0] },  // top
    { verts: [0,2,6,4], normal: [-1,0,0] }, // left
    { verts: [1,3,7,5], normal: [1,0,0] }   // right
  ];

  function draw() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const W = rect.width;
    const H = 520;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    ctx.fillStyle = '#0c1222';
    ctx.fillRect(0, 0, W, H);

    const cx = W / 2;
    const cy = H / 2 - 10;
    const scale = Math.min(W, H) * 0.22;
    const fov = 5;

    const speed = parseInt(rotSpeedEl.value) / 1000;
    if (!dragging && speed > 0) {
      autoAngle += speed;
      angleY = autoAngle;
    }

    // Transform cube vertices
    const transformed = cubeVerts.map(v => {
      let p = rotateY(v, angleY);
      p = rotateX(p, angleX);
      return p;
    });
    const projected = transformed.map(p => project(p, cx, cy, scale, fov));

    const showCube = showCubeEl.checked;
    const showSphere = showSphereEl.checked;
    const showRadius = showRadiusEl.checked;
    const showLabels = showLabelsEl.checked;

    // Draw cube faces (semi-transparent, back-face culled for depth)
    if (showCube) {
      // Sort faces by average z (painter's algorithm)
      const facesWithDepth = cubeFaces.map((face, fi) => {
        const avgZ = face.verts.reduce((s, vi) => s + transformed[vi][2], 0) / 4;
        return { face, avgZ, fi };
      });
      facesWithDepth.sort((a, b) => a.avgZ - b.avgZ);

      facesWithDepth.forEach(({ face, fi }) => {
        const pts = face.verts.map(vi => projected[vi]);
        // Check if face is front-facing
        const ax = pts[1][0] - pts[0][0], ay = pts[1][1] - pts[0][1];
        const bx = pts[2][0] - pts[0][0], by = pts[2][1] - pts[0][1];
        const cross = ax * by - ay * bx;

        ctx.beginPath();
        ctx.moveTo(pts[0][0], pts[0][1]);
        for (let i = 1; i < pts.length; i++) {
          ctx.lineTo(pts[i][0], pts[i][1]);
        }
        ctx.closePath();

        if (cross > 0) {
          // Front face
          ctx.fillStyle = 'rgba(96, 165, 250, 0.06)';
          ctx.fill();
          ctx.strokeStyle = 'rgba(96, 165, 250, 0.5)';
          ctx.lineWidth = 1.8;
          ctx.stroke();
        } else {
          // Back face
          ctx.fillStyle = 'rgba(96, 165, 250, 0.02)';
          ctx.fill();
          ctx.strokeStyle = 'rgba(96, 165, 250, 0.15)';
          ctx.lineWidth = 0.8;
          ctx.setLineDash([4, 4]);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      });
    }

    // Draw sphere as wireframe great circles
    if (showSphere) {
      const numCircles = 5;
      const numPoints = 80;

      // Draw latitude circles
      for (let c = 0; c < numCircles; c++) {
        const phi = (Math.PI / (numCircles + 1)) * (c + 1);
        const r = Math.sin(phi);
        const y = Math.cos(phi);
        ctx.beginPath();
        let first = true;
        for (let i = 0; i <= numPoints; i++) {
          const theta = (2 * Math.PI / numPoints) * i;
          let p = [r * Math.cos(theta), y, r * Math.sin(theta)];
          p = rotateY(p, angleY);
          p = rotateX(p, angleX);
          const pp = project(p, cx, cy, scale, fov);
          if (first) { ctx.moveTo(pp[0], pp[1]); first = false; }
          else { ctx.lineTo(pp[0], pp[1]); }
        }
        ctx.strokeStyle = 'rgba(167, 139, 250, 0.25)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Draw longitude circles
      for (let c = 0; c < numCircles; c++) {
        const theta0 = (Math.PI / numCircles) * c;
        ctx.beginPath();
        let first = true;
        for (let i = 0; i <= numPoints; i++) {
          const phi = (2 * Math.PI / numPoints) * i;
          let p = [Math.sin(phi) * Math.cos(theta0), Math.cos(phi), Math.sin(phi) * Math.sin(theta0)];
          p = rotateY(p, angleY);
          p = rotateX(p, angleX);
          const pp = project(p, cx, cy, scale, fov);
          if (first) { ctx.moveTo(pp[0], pp[1]); first = false; }
          else { ctx.lineTo(pp[0], pp[1]); }
        }
        ctx.strokeStyle = 'rgba(167, 139, 250, 0.25)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Draw equator and two main meridians with stronger color
      const mainCircles = [
        // equator (y=0)
        (i) => { const t = (2*Math.PI/numPoints)*i; return [Math.cos(t), 0, Math.sin(t)]; },
        // xz meridian
        (i) => { const t = (2*Math.PI/numPoints)*i; return [Math.sin(t), Math.cos(t), 0]; },
        // yz meridian
        (i) => { const t = (2*Math.PI/numPoints)*i; return [0, Math.cos(t), Math.sin(t)]; }
      ];
      mainCircles.forEach(fn => {
        ctx.beginPath();
        let first = true;
        for (let i = 0; i <= numPoints; i++) {
          let p = fn(i);
          p = rotateY(p, angleY);
          p = rotateX(p, angleX);
          const pp = project(p, cx, cy, scale, fov);
          if (first) { ctx.moveTo(pp[0], pp[1]); first = false; }
          else { ctx.lineTo(pp[0], pp[1]); }
        }
        ctx.strokeStyle = 'rgba(167, 139, 250, 0.55)';
        ctx.lineWidth = 1.8;
        ctx.stroke();
      });

      // Sphere surface shading (gradient overlay)
      const center3d = [0, 0, 0];
      const centerRot = rotateX(rotateY(center3d, angleY), angleX);
      const centerProj = project(centerRot, cx, cy, scale, fov);

      // Calculate projected radius for the sphere highlight
      const edgePt = rotateX(rotateY([1, 0, 0], angleY), angleX);
      const edgeProj = project(edgePt, cx, cy, scale, fov);
      const projRadius = Math.hypot(edgeProj[0] - centerProj[0], edgeProj[1] - centerProj[1]);

      const grad = ctx.createRadialGradient(
        centerProj[0] - projRadius * 0.3, centerProj[1] - projRadius * 0.3, projRadius * 0.05,
        centerProj[0], centerProj[1], projRadius
      );
      grad.addColorStop(0, 'rgba(167, 139, 250, 0.12)');
      grad.addColorStop(0.5, 'rgba(167, 139, 250, 0.04)');
      grad.addColorStop(1, 'rgba(167, 139, 250, 0.0)');

      ctx.beginPath();
      ctx.arc(centerProj[0], centerProj[1], projRadius, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.fill();
    }

    // Draw radius line
    if (showRadius) {
      const center = [0, 0, 0];
      const radiusEnd = [1, 0, 0]; // touches right face
      const touchPoint = [0, 0, 1]; // touches front face

      let cRot = rotateX(rotateY(center, angleY), angleX);
      let rRot = rotateX(rotateY(radiusEnd, angleY), angleX);
      let tRot = rotateX(rotateY(touchPoint, angleY), angleX);

      const cP = project(cRot, cx, cy, scale, fov);
      const rP = project(rRot, cx, cy, scale, fov);
      const tP = project(tRot, cx, cy, scale, fov);

      // Radius line to right face
      ctx.beginPath();
      ctx.moveTo(cP[0], cP[1]);
      ctx.lineTo(rP[0], rP[1]);
      ctx.strokeStyle = '#f472b6';
      ctx.lineWidth = 2.5;
      ctx.stroke();

      // Center dot
      ctx.beginPath();
      ctx.arc(cP[0], cP[1], 5, 0, Math.PI * 2);
      ctx.fillStyle = '#f472b6';
      ctx.fill();

      // Touch point dot
      ctx.beginPath();
      ctx.arc(rP[0], rP[1], 4, 0, Math.PI * 2);
      ctx.fillStyle = '#34d399';
      ctx.fill();

      // Radius to front face
      ctx.beginPath();
      ctx.moveTo(cP[0], cP[1]);
      ctx.lineTo(tP[0], tP[1]);
      ctx.strokeStyle = 'rgba(244, 114, 182, 0.4)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([5, 5]);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.beginPath();
      ctx.arc(tP[0], tP[1], 4, 0, Math.PI * 2);
      ctx.fillStyle = '#34d399';
      ctx.fill();

      if (showLabels) {
        // Label r = a/2
        const midX = (cP[0] + rP[0]) / 2;
        const midY = (cP[1] + rP[1]) / 2;
        ctx.fillStyle = '#f472b6';
        ctx.font = 'bold 15px Segoe UI, system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('r = a/2', midX, midY - 12);
      }
    }

    // Labels
    if (showLabels) {
      // Side length label on a visible edge
      const e0 = projected[0]; // (-1,-1,-1)
      const e1 = projected[1]; // (1,-1,-1)
      const eMidX = (e0[0] + e1[0]) / 2;
      const eMidY = (e0[1] + e1[1]) / 2;

      ctx.fillStyle = '#60a5fa';
      ctx.font = 'bold 14px Segoe UI, system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('a', eMidX, eMidY + 22);

      // Title
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 15px Segoe UI, system-ui, sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Lopta upisana u kocku', 20, 28);

      // Info text
      ctx.fillStyle = '#94a3b8';
      ctx.font = '13px Segoe UI, system-ui, sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('Precnik lopte = stranica kocke', 20, 48);

      // Formula bottom
      ctx.fillStyle = '#4ade80';
      ctx.font = 'bold 16px Segoe UI, system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('P(lopte)/P(kocke) = \u03C0a\u00B2 / 6a\u00B2 = \u03C0/6', cx, H - 25);

      // Surface values
      ctx.fillStyle = '#a78bfa';
      ctx.font = '13px Segoe UI, system-ui, sans-serif';
      ctx.fillText('P(lopte) = 4\u03C0r\u00B2 = \u03C0a\u00B2     |     P(kocke) = 6a\u00B2', cx, H - 50);
    }
  }

  function animate() {
    draw();
    requestAnimationFrame(animate);
  }

  // Control event listeners
  [showSphereEl, showCubeEl, showRadiusEl, showLabelsEl].forEach(el => {
    el.addEventListener('change', draw);
  });

  animate();

  // Redraw on resize
  window.addEventListener('resize', draw);
})();
</script>

</body>
</html>
<!--BRAINSPARK_META
{
  "title": "Odnos povrsina lopte upisane u kocku",
  "subject": "math",
  "unit": "solid_geometry",
  "topic_tags": ["stereometrija", "lopta", "kocka", "upisana lopta", "povrsina", "odnos povrsina"]
}
BRAINSPARK_META-->