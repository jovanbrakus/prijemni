<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Zapremina trostrane piramide sa pravouglim bočnim stranama</title>

<script type="text/info" id="logic-scratchpad">
PROBLEM:
Bočne strane trostrane piramide su pravougli trouglovi sa temenom pravog ugla u vrhu piramide.
Površine tih bočnih strana su 6 cm², 8 cm² i 12 cm².
Zapremina piramide je:
(A) 6 cm³  (B) 8√2 cm³  (C) 8 cm³  (D) 6√2 cm³  (E) 12 cm³

SOLUTION:

Step 1: Set up variables.
Let the apex of the pyramid be S, and the three base vertices be A, B, C.
The three lateral edges from S are: SA = a, SB = b, SC = c.
Since each lateral face is a right triangle with the right angle at the apex S,
the edges a, b, c are MUTUALLY PERPENDICULAR at S.

Step 2: Write face area equations.
Face SAB: right angle at S, legs a and b. Area = (1/2)ab = 6  =>  ab = 12
Face SAC: right angle at S, legs a and c. Area = (1/2)ac = 8  =>  ac = 16
Face SBC: right angle at S, legs b and c. Area = (1/2)bc = 12  =>  bc = 24

Step 3: Find a, b, c.
Multiply all three: (ab)(ac)(bc) = 12 · 16 · 24 = 4608
(abc)² = 4608
abc = √4608

Simplify: 4608 = 2^9 · 3^2 = 512 · 9
√4608 = √(512 · 9) = √512 · 3 = 16√2 · 3 = 48√2

So abc = 48√2.

Step 4: Find individual values.
From abc = 48√2 and ab = 12: c = 48√2 / 12 = 4√2
From abc = 48√2 and ac = 16: b = 48√2 / 16 = 3√2
From abc = 48√2 and bc = 24: a = 48√2 / 24 = 2√2

Verify: ab = 2√2 · 3√2 = 6·2 = 12 ✓
        ac = 2√2 · 4√2 = 8·2 = 16 ✓
        bc = 3√2 · 4√2 = 12·2 = 24 ✓

Step 5: Compute volume.
Since a, b, c are mutually perpendicular at S, the tetrahedron has the same volume
as (1/6) of the rectangular parallelepiped with edges a, b, c:

V = (1/6) · a · b · c = (1/6) · 48√2 = 8√2 cm³

Step 6: Verify the formula V = (1/6)abc.
Place S at the origin with edges along coordinate axes:
S = (0,0,0), A = (a,0,0), B = (0,b,0), C = (0,0,c).
Volume of tetrahedron = (1/6)|det[SA, SB, SC]| = (1/6)|det of diagonal matrix| = (1/6)abc. ✓

ANSWER: (B) 8√2 cm³
</script>

<script>
MathJax = {
  tex: {
    inlineMath: [['\\(', '\\)'], ['$', '$']],
    displayMath: [['\\[', '\\]']]
  },
  svg: { fontCache: 'global' }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0f172a;
  color: #e2e8f0;
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  line-height: 1.7;
  padding: 20px;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

h1 {
  font-size: 2.2rem;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 8px;
  line-height: 1.3;
}

.subtitle {
  color: #94a3b8;
  font-size: 1.1rem;
  margin-bottom: 30px;
}

.card {
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 14px;
  padding: 24px;
  margin-bottom: 24px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.35);
}

.card h2 {
  color: #60a5fa;
  font-size: 1.4rem;
  margin-bottom: 16px;
}

.highlight {
  color: #f472b6;
  font-weight: 600;
}

.math-box {
  background: rgba(56,189,248,0.08);
  border: 1px solid rgba(56,189,248,0.15);
  border-radius: 8px;
  padding: 14px 18px;
  margin: 12px 0;
  font-family: 'Courier New', monospace;
  overflow-x: auto;
}

.given-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 16px;
}

.given-item {
  background: rgba(96,165,250,0.08);
  border: 1px solid rgba(96,165,250,0.18);
  border-radius: 10px;
  padding: 12px 18px;
  min-width: 80px;
  text-align: center;
}

.given-item .label {
  color: #94a3b8;
  font-size: 0.85rem;
  margin-bottom: 4px;
}

.given-item .value {
  color: #e2e8f0;
  font-size: 1.1rem;
  font-weight: 600;
}

.answer-option {
  cursor: default;
  transition: border-color 0.2s;
}

.plan-card {
  border-left: 3px solid #a78bfa;
}

details {
  margin: 15px 0;
}

details summary {
  cursor: pointer;
  color: #60a5fa;
  font-weight: 600;
  padding: 10px 0;
  user-select: none;
}

details summary:hover {
  color: #93bbfc;
}

details[open] summary {
  margin-bottom: 10px;
}

.theory-content ul {
  list-style: none;
  padding-left: 0;
}

.theory-content li {
  padding: 8px 0;
  border-bottom: 1px solid rgba(51,65,85,0.5);
  color: #cbd5e1;
}

.theory-content li:last-child {
  border-bottom: none;
}

.canvas-card {
  text-align: center;
}

canvas {
  border-radius: 10px;
  width: 100%;
  max-width: 700px;
  touch-action: none;
}

.step-container {
  margin-bottom: 18px;
  padding: 18px;
  padding-left: 24px;
  background: rgba(30,41,59,0.5);
  border-left: 3px solid #334155;
  border-radius: 0 10px 10px 0;
  cursor: pointer;
  transition: border-color 0.25s, background 0.25s;
}

.step-container:hover,
.step-container.active {
  border-left-color: #4ade80;
  background: rgba(30,41,59,0.9);
}

.step-badge {
  display: inline-block;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  color: #0f172a;
  font-weight: 700;
  font-size: 0.8rem;
  padding: 3px 10px;
  border-radius: 20px;
  margin-bottom: 8px;
}

.step-title {
  font-size: 1.1rem;
  font-weight: 600;
  color: #e2e8f0;
  margin-bottom: 8px;
}

.step-text {
  color: #cbd5e1;
  font-size: 0.97rem;
}

.checkpoint {
  background: rgba(167,139,250,0.08);
  border: 1px solid rgba(167,139,250,0.2);
  border-radius: 8px;
  padding: 12px 16px;
  margin: 15px 0;
}

.checkpoint summary {
  color: #a78bfa;
}

.insight-box {
  background: linear-gradient(135deg, rgba(96,165,250,0.12), rgba(167,139,250,0.12));
  border: 1px solid rgba(167,139,250,0.25);
  border-radius: 14px;
  padding: 22px;
  margin-bottom: 24px;
}

.insight-box h3 {
  color: #a78bfa;
  margin-bottom: 10px;
}

.final-answer {
  text-align: center;
  padding: 30px;
  border: 2px solid rgba(74,222,128,0.3);
  background: rgba(74,222,128,0.06);
}

.final-answer .answer-value {
  font-size: 2rem;
  font-weight: 700;
  color: #4ade80;
  margin: 16px 0;
}

.final-answer .answer-label {
  color: #94a3b8;
  font-size: 0.95rem;
}

.options-row {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 12px;
  margin: 20px 0;
}

.option-box {
  padding: 12px 22px;
  border-radius: 10px;
  border: 2px solid #334155;
  background: rgba(30,41,59,0.6);
  color: #94a3b8;
  font-size: 1.05rem;
  font-weight: 600;
  transition: all 0.3s;
}

.option-box.correct {
  border-color: #4ade80;
  background: rgba(74,222,128,0.12);
  color: #4ade80;
}

.pitfall-list {
  list-style: none;
  padding: 0;
}

.pitfall-list li {
  padding: 10px 0;
  padding-left: 16px;
  position: relative;
  color: #cbd5e1;
}

.pitfall-list li::before {
  content: '\26A0';
  position: absolute;
  left: 0;
}

.challenge-box {
  border-left: 3px solid #f472b6;
}

.verification-note {
  color: #94a3b8;
  font-size: 0.9rem;
  margin-top: 10px;
}

.drag-hint {
  color: #64748b;
  font-size: 0.85rem;
  margin-top: 8px;
}

@media (max-width: 700px) {
  h1 { font-size: 1.5rem; }
  .container { padding: 10px; }
  .card { padding: 16px; }
  .given-grid { flex-direction: column; }
  .options-row { flex-direction: column; align-items: center; }
}
</style>
</head>
<body>
<div class="container">

  <h1>Zapremina trostrane piramide sa pravouglim bočnim stranama</h1>
  <p class="subtitle">Stereometrija, trostrana piramida, uzajamno normalne ivice</p>

  <!-- PROBLEM STATEMENT -->
  <div class="card problem-statement">
    <h2>Zadatak</h2>
    <p>Bočne strane trostrane piramide su <span class="highlight">pravougli trouglovi</span> sa temenom pravog ugla u <span class="highlight">vrhu piramide</span>. Površine tih bočnih strana su <span class="highlight">6 cm²</span>, <span class="highlight">8 cm²</span> i <span class="highlight">12 cm²</span>. Zapremina piramide je:</p>

    <div class="given-grid" style="margin-bottom: 16px;">
      <div class="given-item">
        <div class="label">Površina 1</div>
        <div class="value">\(P_1 = 6\) cm²</div>
      </div>
      <div class="given-item">
        <div class="label">Površina 2</div>
        <div class="value">\(P_2 = 8\) cm²</div>
      </div>
      <div class="given-item">
        <div class="label">Površina 3</div>
        <div class="value">\(P_3 = 12\) cm²</div>
      </div>
    </div>

    <div class="given-grid">
      <div class="given-item answer-option" data-option="A">
        <div class="label">(A)</div>
        <div class="value">\(6\) cm³</div>
      </div>
      <div class="given-item answer-option" data-option="B">
        <div class="label">(B)</div>
        <div class="value">\(8\sqrt{2}\) cm³</div>
      </div>
      <div class="given-item answer-option" data-option="C">
        <div class="label">(C)</div>
        <div class="value">\(8\) cm³</div>
      </div>
      <div class="given-item answer-option" data-option="D">
        <div class="label">(D)</div>
        <div class="value">\(6\sqrt{2}\) cm³</div>
      </div>
      <div class="given-item answer-option" data-option="E">
        <div class="label">(E)</div>
        <div class="value">\(12\) cm³</div>
      </div>
    </div>
  </div>

  <!-- PLAN -->
  <div class="card plan-card">
    <h2>Plan rešavanja</h2>
    <p>Pošto su sve tri bočne strane pravougli trouglovi sa pravim uglom u vrhu piramide, tri bočne ivice iz vrha su <span class="highlight">uzajamno normalne</span>. Označićemo ih sa \(a\), \(b\), \(c\), postaviti sistem jednačina za površine bočnih strana, rešiti ga, i primeniti formulu za zapreminu tetraedra sa tri uzajamno normalne ivice: \(V = \frac{1}{6}abc\).</p>
  </div>

  <!-- THEORY -->
  <div class="card">
    <details>
      <summary>Ključne formule i teoreme</summary>
      <div class="theory-content">
        <ul>
          <li><strong>Površina pravouglog trougla:</strong> Ako su katete dužina \(p\) i \(q\), površina je \(P = \frac{1}{2}pq\).</li>
          <li><strong>Zapremina tetraedra sa tri uzajamno normalne ivice u temenu:</strong> Ako su \(a\), \(b\), \(c\) tri međusobno normalne ivice iz jednog temena, zapremina je \(V = \frac{1}{6}abc\). Ovo sledi iz činjenice da je takav tetraedron "ugao" kvadra sa ivicama \(a\), \(b\), \(c\), a zapremina tetraedra je \(\frac{1}{6}\) zapremine tog kvadra.</li>
          <li><strong>Proizvod parova:</strong> Iz sistema \(ab = p\), \(ac = q\), \(bc = r\) sledi \((abc)^2 = pqr\), pa je \(abc = \sqrt{pqr}\).</li>
        </ul>
        <canvas id="theoryCanvas" width="400" height="250"></canvas>
        <p class="drag-hint">Ilustracija: tetraedar kao ugao kvadra</p>
      </div>
    </details>
  </div>

  <!-- VISUAL AID -->
  <div class="card canvas-card">
    <h2>3D prikaz piramide</h2>
    <p style="color:#94a3b8; margin-bottom:14px;">Interaktivni dijagram trostrane piramide sa tri uzajamno normalne ivice u vrhu \(S\).</p>
    <canvas id="diagram3d" width="700" height="550"></canvas>
    <p class="drag-hint">Prevucite mišem za rotaciju piramide</p>
  </div>

  <!-- STEP-BY-STEP -->
  <div class="card">
    <h2>Rešenje korak po korak</h2>

    <!-- Step 1 -->
    <div class="step-container" id="step1">
      <span class="step-badge">Korak 1</span>
      <div class="step-title">Definisanje promenljivih</div>
      <div class="step-text">
        <p>Neka je \(S\) vrh piramide, a \(A\), \(B\), \(C\) temena osnove. Bočne ivice iz vrha \(S\) označavamo sa:</p>
        <div class="math-box">
          \[ a = SA, \quad b = SB, \quad c = SC \]
        </div>
        <p>Pošto je svaka bočna strana pravougli trougao sa pravim uglom u \(S\), zaključujemo da su ivice \(a\), \(b\) i \(c\) <span class="highlight">uzajamno normalne</span> (međusobno upravne).</p>
      </div>
    </div>

    <!-- Step 2 -->
    <div class="step-container" id="step2">
      <span class="step-badge">Korak 2</span>
      <div class="step-title">Postavljanje jednačina za površine</div>
      <div class="step-text">
        <p>Svaka bočna strana je pravougli trougao čije su katete dve od tri ivice \(a\), \(b\), \(c\). Površine su:</p>
        <div class="math-box">
          \[ \frac{1}{2}ab = 6 \quad \Rightarrow \quad ab = 12 \]
        </div>
        <div class="math-box">
          \[ \frac{1}{2}ac = 8 \quad \Rightarrow \quad ac = 16 \]
        </div>
        <div class="math-box">
          \[ \frac{1}{2}bc = 12 \quad \Rightarrow \quad bc = 24 \]
        </div>
      </div>
    </div>

    <!-- Checkpoint 1 -->
    <details class="checkpoint">
      <summary>Proveri se: Zašto su ivice \(a\), \(b\), \(c\) uzajamno normalne?</summary>
      <p style="padding-top:8px; color:#cbd5e1;">
        Bočna strana \(SAB\) je pravougli trougao sa pravim uglom u \(S\), što znači da je \(SA \perp SB\), tj. \(a \perp b\). Isto važi za parove \(a \perp c\) (iz trougla \(SAC\)) i \(b \perp c\) (iz trougla \(SBC\)). Dakle, sve tri ivice su međusobno normalne.
      </p>
    </details>

    <!-- Step 3 -->
    <div class="step-container" id="step3">
      <span class="step-badge">Korak 3</span>
      <div class="step-title">Nalaženje proizvoda \(abc\)</div>
      <div class="step-text">
        <p>Pomnožimo sve tri jednačine:</p>
        <div class="math-box">
          \[ (ab)(ac)(bc) = 12 \cdot 16 \cdot 24 \]
        </div>
        <p>Leva strana se pojednostavljuje:</p>
        <div class="math-box">
          \[ (ab)(ac)(bc) = a^2 b^2 c^2 = (abc)^2 \]
        </div>
        <p>Desna strana:</p>
        <div class="math-box">
          \[ 12 \cdot 16 = 192 \]
        </div>
        <div class="math-box">
          \[ 192 \cdot 24 = 4608 \]
        </div>
        <p>Dakle:</p>
        <div class="math-box">
          \[ (abc)^2 = 4608 \]
        </div>
      </div>
    </div>

    <!-- Step 4 -->
    <div class="step-container" id="step4">
      <span class="step-badge">Korak 4</span>
      <div class="step-title">Korenovanje i uprošćavanje</div>
      <div class="step-text">
        <p>Rastavimo 4608 na proste činioce:</p>
        <div class="math-box">
          \[ 4608 = 2^9 \cdot 3^2 = 512 \cdot 9 \]
        </div>
        <p>Korenujemo:</p>
        <div class="math-box">
          \[ abc = \sqrt{4608} = \sqrt{2^9 \cdot 3^2} = 2^4 \cdot 3 \cdot \sqrt{2} = 48\sqrt{2} \]
        </div>
        <p style="color:#94a3b8;">Obrazloženje: \(\sqrt{2^9} = \sqrt{2^8 \cdot 2} = 2^4 \sqrt{2} = 16\sqrt{2}\), pa \(16\sqrt{2} \cdot 3 = 48\sqrt{2}\).</p>
      </div>
    </div>

    <!-- Step 5 -->
    <div class="step-container" id="step5">
      <span class="step-badge">Korak 5</span>
      <div class="step-title">Nalaženje pojedinačnih vrednosti \(a\), \(b\), \(c\)</div>
      <div class="step-text">
        <p>Iz \(abc = 48\sqrt{2}\) i pojedinačnih jednačina:</p>
        <div class="math-box">
          \[ c = \frac{abc}{ab} = \frac{48\sqrt{2}}{12} = 4\sqrt{2} \]
        </div>
        <div class="math-box">
          \[ b = \frac{abc}{ac} = \frac{48\sqrt{2}}{16} = 3\sqrt{2} \]
        </div>
        <div class="math-box">
          \[ a = \frac{abc}{bc} = \frac{48\sqrt{2}}{24} = 2\sqrt{2} \]
        </div>
      </div>
    </div>

    <!-- Checkpoint 2 -->
    <details class="checkpoint">
      <summary>Proveri se: Da li su dobijene vrednosti tačne?</summary>
      <p style="padding-top:8px; color:#cbd5e1;">
        Proverimo površine:<br>
        \(\frac{1}{2}ab = \frac{1}{2} \cdot 2\sqrt{2} \cdot 3\sqrt{2} = \frac{1}{2} \cdot 12 = 6\) cm² &mdash; tačno!<br>
        \(\frac{1}{2}ac = \frac{1}{2} \cdot 2\sqrt{2} \cdot 4\sqrt{2} = \frac{1}{2} \cdot 16 = 8\) cm² &mdash; tačno!<br>
        \(\frac{1}{2}bc = \frac{1}{2} \cdot 3\sqrt{2} \cdot 4\sqrt{2} = \frac{1}{2} \cdot 24 = 12\) cm² &mdash; tačno!
      </p>
    </details>

    <!-- Step 6 -->
    <div class="step-container" id="step6">
      <span class="step-badge">Korak 6</span>
      <div class="step-title">Izračunavanje zapremine</div>
      <div class="step-text">
        <p>Za tetraedar čije su tri ivice iz jednog temena uzajamno normalne važi formula:</p>
        <div class="math-box">
          \[ V = \frac{1}{6} \cdot a \cdot b \cdot c \]
        </div>
        <p>Ovo se može dokazati postavljanjem koordinatnog sistema: ako je \(S\) u koordinatnom početku i ivice duž osa, tada je \(A = (a,0,0)\), \(B = (0,b,0)\), \(C = (0,0,c)\), pa je zapremina tetraedra:</p>
        <div class="math-box">
          \[ V = \frac{1}{6}\left|\det\begin{pmatrix} a & 0 & 0 \\ 0 & b & 0 \\ 0 & 0 & c \end{pmatrix}\right| = \frac{1}{6}abc \]
        </div>
        <p>Uvrštavamo:</p>
        <div class="math-box">
          \[ V = \frac{1}{6} \cdot 48\sqrt{2} = \frac{48\sqrt{2}}{6} = 8\sqrt{2} \text{ cm}^3 \]
        </div>
      </div>
    </div>

    <!-- Checkpoint 3 -->
    <details class="checkpoint">
      <summary>Proveri se: Numerička provera</summary>
      <p style="padding-top:8px; color:#cbd5e1;">
        \(8\sqrt{2} \approx 8 \cdot 1{,}414 = 11{,}31\) cm³.<br>
        Alternativno: \(V = \frac{1}{6} \cdot 2\sqrt{2} \cdot 3\sqrt{2} \cdot 4\sqrt{2} = \frac{1}{6} \cdot 2 \cdot 3 \cdot 4 \cdot (\sqrt{2})^3 = \frac{24 \cdot 2\sqrt{2}}{6} = \frac{48\sqrt{2}}{6} = 8\sqrt{2}\). Sve se poklapa.
      </p>
    </details>
  </div>

  <!-- KEY INSIGHT -->
  <div class="insight-box">
    <h3>Ključni uvid</h3>
    <p>Kada su sve tri bočne strane piramide pravougli trouglovi sa pravim uglom u istom temenu, bočne ivice iz tog temena su <span class="highlight">uzajamno normalne</span>. Takav tetraedar je zapravo "ugao" pravouglog paralelopipeda (kutija) sa ivicama \(a\), \(b\), \(c\), a njegova zapremina je tačno <span class="highlight">jedna šestina</span> zapremine te kutije.</p>
    <div class="math-box" style="text-align: center; font-size: 1.1rem;">
      \[ V = \frac{1}{6}abc = \frac{1}{6} \cdot 48\sqrt{2} = 8\sqrt{2} \text{ cm}^3 \]
    </div>
  </div>

  <!-- FINAL ANSWER -->
  <div class="card final-answer">
    <h2>Konačan odgovor</h2>
    <p class="answer-label">Zapremina trostrane piramide je:</p>
    <div class="answer-value">\(\displaystyle \text{(B)}\ 8\sqrt{2} \text{ cm}^3\)</div>
    <div class="options-row">
      <div class="option-box">(A) \(6\) cm³</div>
      <div class="option-box correct">(B) \(8\sqrt{2}\) cm³</div>
      <div class="option-box">(C) \(8\) cm³</div>
      <div class="option-box">(D) \(6\sqrt{2}\) cm³</div>
      <div class="option-box">(E) \(12\) cm³</div>
    </div>
    <p class="verification-note">Provera: \(a = 2\sqrt{2}\), \(b = 3\sqrt{2}\), \(c = 4\sqrt{2}\). Površine bočnih strana: \(\frac{1}{2} \cdot 12 = 6\), \(\frac{1}{2} \cdot 16 = 8\), \(\frac{1}{2} \cdot 24 = 12\). Zapremina: \(\frac{1}{6} \cdot 48\sqrt{2} = 8\sqrt{2} \approx 11{,}31\) cm³.</p>
  </div>

  <!-- PITFALLS -->
  <div class="card">
    <h2>Česte greške</h2>
    <ul class="pitfall-list">
      <li>Pogrešna formula za zapreminu: korišćenje \(V = \frac{1}{3}Bh\) sa pogrešno izračunatom bazom. Kod ovog tipa piramide najjednostavnije je koristiti \(V = \frac{1}{6}abc\).</li>
      <li>Greška pri korenovanje broja 4608: zaboraviti da \(\sqrt{2^9} = 16\sqrt{2}\), a ne \(16\) ili \(32\sqrt{2}\). Sistematična faktorizacija pomaže.</li>
    </ul>
  </div>

  <!-- CHALLENGE -->
  <div class="card challenge-box">
    <h2>Dodatni izazov</h2>
    <p>Ako su površine bočnih strana iste piramide (sa pravim uglovima u vrhu) jednake \(P_1\), \(P_2\), \(P_3\), pokažite da je zapremina data opštom formulom:</p>
    <div class="math-box" style="text-align:center;">
      \[ V = \frac{1}{3}\sqrt{\frac{(2P_1)(2P_2)(2P_3)}{1}} \cdot \frac{1}{\sqrt[3]{?}} \]
    </div>
    <p>Tačnije, izvedite zatvoren izraz za \(V\) samo u funkciji od \(P_1\), \(P_2\), \(P_3\).</p>
    <details>
      <summary>Pomoć</summary>
      <p style="padding-top:8px; color:#cbd5e1;">
        Ponovite postupak: \(ab = 2P_1\), \(ac = 2P_2\), \(bc = 2P_3\). Tada \((abc)^2 = 8P_1 P_2 P_3\), pa \(abc = 2\sqrt{2P_1 P_2 P_3}\). Konačno: \(V = \frac{1}{6}abc = \frac{1}{3}\sqrt{2P_1 P_2 P_3}\). Proverite za \(P_1 = 6\), \(P_2 = 8\), \(P_3 = 12\).
      </p>
    </details>
  </div>

</div>

<script>
(() => {
  // Step click highlighting
  const steps = document.querySelectorAll('.step-container');
  steps.forEach(step => {
    step.addEventListener('click', () => {
      steps.forEach(s => s.classList.remove('active'));
      step.classList.toggle('active');
    });
  });

  // Theory canvas: illustration of tetrahedron as corner of a box
  const tc = document.getElementById('theoryCanvas');
  if (tc) {
    const tctx = tc.getContext('2d');
    const tw = tc.width;
    const th = tc.height;

    tctx.fillStyle = '#0c1222';
    tctx.fillRect(0, 0, tw, th);

    // Simple isometric projection of a box corner
    const ox = 160, oy = 180;
    const ax = [100, 0];  // a-axis direction (right)
    const bx = [-50, -40]; // b-axis direction (left-up)
    const cx = [0, -120];  // c-axis direction (up)

    function proj(a, b, c) {
      return [
        ox + a * ax[0]/100 + b * bx[0]/100 + c * cx[0]/100,
        oy + a * ax[1]/100 + b * bx[1]/100 + c * cx[1]/100
      ];
    }

    const S = proj(0, 0, 0);
    const A = proj(100, 0, 0);
    const B = proj(0, 100, 0);
    const C = proj(0, 0, 100);

    // Box ghost edges (dashed)
    const AB2 = proj(100, 100, 0);
    const AC2 = proj(100, 0, 100);
    const BC2 = proj(0, 100, 100);
    const ABC = proj(100, 100, 100);

    tctx.strokeStyle = 'rgba(100,116,139,0.25)';
    tctx.lineWidth = 1;
    tctx.setLineDash([4, 4]);

    function drawLine(p1, p2) {
      tctx.beginPath();
      tctx.moveTo(p1[0], p1[1]);
      tctx.lineTo(p2[0], p2[1]);
      tctx.stroke();
    }

    // Box edges
    drawLine(A, AB2); drawLine(A, AC2);
    drawLine(B, AB2); drawLine(B, BC2);
    drawLine(C, AC2); drawLine(C, BC2);
    drawLine(AB2, ABC); drawLine(AC2, ABC); drawLine(BC2, ABC);
    tctx.setLineDash([]);

    // Tetrahedron faces (semi-transparent)
    // Face SAB
    tctx.fillStyle = 'rgba(96,165,250,0.12)';
    tctx.beginPath();
    tctx.moveTo(S[0], S[1]);
    tctx.lineTo(A[0], A[1]);
    tctx.lineTo(B[0], B[1]);
    tctx.closePath();
    tctx.fill();

    // Face SAC
    tctx.fillStyle = 'rgba(167,139,250,0.12)';
    tctx.beginPath();
    tctx.moveTo(S[0], S[1]);
    tctx.lineTo(A[0], A[1]);
    tctx.lineTo(C[0], C[1]);
    tctx.closePath();
    tctx.fill();

    // Face SBC
    tctx.fillStyle = 'rgba(244,114,182,0.12)';
    tctx.beginPath();
    tctx.moveTo(S[0], S[1]);
    tctx.lineTo(B[0], B[1]);
    tctx.lineTo(C[0], C[1]);
    tctx.closePath();
    tctx.fill();

    // Base ABC
    tctx.fillStyle = 'rgba(52,211,153,0.08)';
    tctx.beginPath();
    tctx.moveTo(A[0], A[1]);
    tctx.lineTo(B[0], B[1]);
    tctx.lineTo(C[0], C[1]);
    tctx.closePath();
    tctx.fill();

    // Tetrahedron edges
    tctx.strokeStyle = '#60a5fa';
    tctx.lineWidth = 2.5;
    drawLine(S, A);
    tctx.strokeStyle = '#a78bfa';
    drawLine(S, B);
    tctx.strokeStyle = '#f472b6';
    drawLine(S, C);
    tctx.strokeStyle = '#34d399';
    tctx.lineWidth = 1.5;
    drawLine(A, B);
    drawLine(A, C);
    drawLine(B, C);

    // Right angle markers at S
    function drawRightAngle(p1, center, p2, size) {
      const d1 = [(p1[0] - center[0]), (p1[1] - center[1])];
      const d2 = [(p2[0] - center[0]), (p2[1] - center[1])];
      const len1 = Math.sqrt(d1[0]*d1[0] + d1[1]*d1[1]);
      const len2 = Math.sqrt(d2[0]*d2[0] + d2[1]*d2[1]);
      const u1 = [d1[0]/len1 * size, d1[1]/len1 * size];
      const u2 = [d2[0]/len2 * size, d2[1]/len2 * size];

      tctx.strokeStyle = '#4ade80';
      tctx.lineWidth = 1.5;
      tctx.beginPath();
      tctx.moveTo(center[0] + u1[0], center[1] + u1[1]);
      tctx.lineTo(center[0] + u1[0] + u2[0], center[1] + u1[1] + u2[1]);
      tctx.lineTo(center[0] + u2[0], center[1] + u2[1]);
      tctx.stroke();
    }

    drawRightAngle(A, S, B, 12);
    drawRightAngle(A, S, C, 12);
    drawRightAngle(B, S, C, 12);

    // Labels
    tctx.font = 'bold 14px Segoe UI, sans-serif';
    tctx.textAlign = 'center';
    tctx.textBaseline = 'middle';

    tctx.fillStyle = '#f472b6';
    tctx.fillText('S', S[0] - 14, S[1] + 12);
    tctx.fillStyle = '#60a5fa';
    tctx.fillText('A', A[0] + 14, A[1] + 6);
    tctx.fillStyle = '#a78bfa';
    tctx.fillText('B', B[0] - 14, B[1] + 2);
    tctx.fillStyle = '#f472b6';
    tctx.fillText('C', C[0] - 8, C[1] - 10);

    // Edge labels
    tctx.font = '12px Segoe UI, sans-serif';
    tctx.fillStyle = '#60a5fa';
    tctx.fillText('a', (S[0]+A[0])/2 + 4, (S[1]+A[1])/2 + 14);
    tctx.fillStyle = '#a78bfa';
    tctx.fillText('b', (S[0]+B[0])/2 - 14, (S[1]+B[1])/2 + 2);
    tctx.fillStyle = '#f472b6';
    tctx.fillText('c', (S[0]+C[0])/2 - 12, (S[1]+C[1])/2);

    // Title
    tctx.fillStyle = '#94a3b8';
    tctx.font = '11px Segoe UI, sans-serif';
    tctx.textAlign = 'center';
    tctx.fillText('V = (1/6) abc', tw/2 + 60, th - 15);
    tctx.fillText('Tetraedar = 1/6 kvadra', tw/2 + 60, th - 32);
  }

  // Main 3D interactive canvas
  const canvas = document.getElementById('diagram3d');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  // Actual edge lengths
  const a = 2 * Math.SQRT2;  // ~2.83
  const b = 3 * Math.SQRT2;  // ~4.24
  const c = 4 * Math.SQRT2;  // ~5.66

  // Rotation angles
  let angleX = -0.45;
  let angleY = 0.65;
  let dragging = false;
  let lastMx = 0, lastMy = 0;

  // Scale factor to fit canvas
  const scale = 42;

  // 3D points: S at origin, A along x, B along y, C along z
  const pts3d = {
    S: [0, 0, 0],
    A: [a, 0, 0],
    B: [0, b, 0],
    C: [0, 0, c],
    // Box corners
    AB: [a, b, 0],
    AC: [a, 0, c],
    BC: [0, b, c],
    ABC: [a, b, c]
  };

  function rotateY(p, angle) {
    const cos = Math.cos(angle), sin = Math.sin(angle);
    return [cos*p[0] + sin*p[2], p[1], -sin*p[0] + cos*p[2]];
  }
  function rotateX(p, angle) {
    const cos = Math.cos(angle), sin = Math.sin(angle);
    return [p[0], cos*p[1] - sin*p[2], sin*p[1] + cos*p[2]];
  }

  function project(p3) {
    let r = rotateY(p3, angleY);
    r = rotateX(r, angleX);
    return {
      x: W/2 + r[0] * scale,
      y: H/2 - r[1] * scale,
      z: r[2]
    };
  }

  function draw3d() {
    ctx.fillStyle = '#0c1222';
    ctx.fillRect(0, 0, W, H);

    // Project all points
    const proj = {};
    for (const key in pts3d) {
      proj[key] = project(pts3d[key]);
    }

    // Draw box ghost edges (dashed)
    ctx.strokeStyle = 'rgba(100,116,139,0.2)';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);

    function line(k1, k2) {
      ctx.beginPath();
      ctx.moveTo(proj[k1].x, proj[k1].y);
      ctx.lineTo(proj[k2].x, proj[k2].y);
      ctx.stroke();
    }

    line('A', 'AB'); line('A', 'AC');
    line('B', 'AB'); line('B', 'BC');
    line('C', 'AC'); line('C', 'BC');
    line('AB', 'ABC'); line('AC', 'ABC'); line('BC', 'ABC');
    ctx.setLineDash([]);

    // Fill tetrahedron faces with transparency
    // Sort faces by average z for basic depth sorting
    const faces = [
      { pts: ['S','A','B'], color: 'rgba(96,165,250,0.15)', label: 'P=6' },
      { pts: ['S','A','C'], color: 'rgba(167,139,250,0.15)', label: 'P=8' },
      { pts: ['S','B','C'], color: 'rgba(244,114,182,0.15)', label: 'P=12' },
      { pts: ['A','B','C'], color: 'rgba(52,211,153,0.10)', label: 'Osnova' }
    ];

    // Compute average z for sorting
    faces.forEach(f => {
      f.avgZ = f.pts.reduce((s, k) => s + proj[k].z, 0) / f.pts.length;
    });
    faces.sort((a2, b2) => a2.avgZ - b2.avgZ);

    faces.forEach(f => {
      ctx.fillStyle = f.color;
      ctx.beginPath();
      ctx.moveTo(proj[f.pts[0]].x, proj[f.pts[0]].y);
      ctx.lineTo(proj[f.pts[1]].x, proj[f.pts[1]].y);
      ctx.lineTo(proj[f.pts[2]].x, proj[f.pts[2]].y);
      ctx.closePath();
      ctx.fill();

      // Face label at centroid
      const cx2 = (proj[f.pts[0]].x + proj[f.pts[1]].x + proj[f.pts[2]].x) / 3;
      const cy2 = (proj[f.pts[0]].y + proj[f.pts[1]].y + proj[f.pts[2]].y) / 3;
      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px Segoe UI, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(f.label, cx2, cy2);
    });

    // Draw tetrahedron edges
    // Edges from S (the lateral edges)
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#60a5fa';
    line('S', 'A');
    ctx.strokeStyle = '#a78bfa';
    line('S', 'B');
    ctx.strokeStyle = '#f472b6';
    line('S', 'C');

    // Base edges
    ctx.strokeStyle = '#34d399';
    ctx.lineWidth = 2;
    line('A', 'B');
    line('A', 'C');
    line('B', 'C');

    // Right angle markers at S
    function drawRightAngle3d(k1, k2, size) {
      const s = pts3d.S;
      const p1 = pts3d[k1];
      const p2 = pts3d[k2];

      const d1 = [p1[0]-s[0], p1[1]-s[1], p1[2]-s[2]];
      const d2 = [p2[0]-s[0], p2[1]-s[1], p2[2]-s[2]];
      const len1 = Math.sqrt(d1[0]*d1[0]+d1[1]*d1[1]+d1[2]*d1[2]);
      const len2 = Math.sqrt(d2[0]*d2[0]+d2[1]*d2[1]+d2[2]*d2[2]);

      const u1 = d1.map(v => v/len1*size);
      const u2 = d2.map(v => v/len2*size);

      const corner1 = [s[0]+u1[0], s[1]+u1[1], s[2]+u1[2]];
      const mid = [s[0]+u1[0]+u2[0], s[1]+u1[1]+u2[1], s[2]+u1[2]+u2[2]];
      const corner2 = [s[0]+u2[0], s[1]+u2[1], s[2]+u2[2]];

      const pc1 = project(corner1);
      const pm = project(mid);
      const pc2 = project(corner2);

      ctx.strokeStyle = '#4ade80';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(pc1.x, pc1.y);
      ctx.lineTo(pm.x, pm.y);
      ctx.lineTo(pc2.x, pc2.y);
      ctx.stroke();
    }

    drawRightAngle3d('A', 'B', 0.7);
    drawRightAngle3d('A', 'C', 0.7);
    drawRightAngle3d('B', 'C', 0.7);

    // Draw edge length labels
    ctx.font = 'bold 13px Segoe UI, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // a = SA edge
    const midSA = project([a/2, 0, 0]);
    ctx.fillStyle = '#60a5fa';
    ctx.fillText('a = 2\u221A2', midSA.x + 8, midSA.y + 18);

    // b = SB edge
    const midSB = project([0, b/2, 0]);
    ctx.fillStyle = '#a78bfa';
    ctx.fillText('b = 3\u221A2', midSB.x - 18, midSB.y + 10);

    // c = SC edge
    const midSC = project([0, 0, c/2]);
    ctx.fillStyle = '#f472b6';
    ctx.fillText('c = 4\u221A2', midSC.x - 22, midSC.y);

    // Vertex labels
    ctx.font = 'bold 15px Segoe UI, sans-serif';

    // S
    ctx.fillStyle = '#e2e8f0';
    const sDir = project([-0.4, -0.4, -0.4]);
    ctx.fillText('S', proj.S.x + (sDir.x - proj.S.x)*2 - 5, proj.S.y + (sDir.y - proj.S.y)*2 + 5);

    // A
    ctx.fillStyle = '#60a5fa';
    ctx.fillText('A', proj.A.x + 16, proj.A.y + 6);

    // B
    ctx.fillStyle = '#a78bfa';
    ctx.fillText('B', proj.B.x - 16, proj.B.y + 6);

    // C
    ctx.fillStyle = '#f472b6';
    ctx.fillText('C', proj.C.x - 8, proj.C.y - 14);

    // Vertex dots
    function drawDot(k, color) {
      ctx.beginPath();
      ctx.arc(proj[k].x, proj[k].y, 7, 0, 2*Math.PI);
      ctx.fillStyle = color + '33';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(proj[k].x, proj[k].y, 4, 0, 2*Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    }

    drawDot('S', '#e2e8f0');
    drawDot('A', '#60a5fa');
    drawDot('B', '#a78bfa');
    drawDot('C', '#f472b6');

    // Legend
    const legX = 15;
    const legY = 15;
    ctx.fillStyle = 'rgba(15,23,42,0.9)';
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(legX, legY, 235, 140, 8);
    ctx.fill();
    ctx.stroke();

    let ly = legY + 20;
    ctx.font = 'bold 12px Segoe UI, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';

    ctx.fillStyle = '#e2e8f0';
    ctx.fillText('Trostrana piramida SABC', legX + 12, ly);
    ly += 22;

    ctx.strokeStyle = '#60a5fa'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(legX+12, ly); ctx.lineTo(legX+32, ly); ctx.stroke();
    ctx.fillStyle = '#60a5fa';
    ctx.font = '11px Segoe UI, sans-serif';
    ctx.fillText('SA = a = 2\u221A2 (P\u2081 = 6 cm\u00B2)', legX+38, ly);
    ly += 20;

    ctx.strokeStyle = '#a78bfa'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(legX+12, ly); ctx.lineTo(legX+32, ly); ctx.stroke();
    ctx.fillStyle = '#a78bfa';
    ctx.fillText('SB = b = 3\u221A2 (P\u2082 = 8 cm\u00B2)', legX+38, ly);
    ly += 20;

    ctx.strokeStyle = '#f472b6'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(legX+12, ly); ctx.lineTo(legX+32, ly); ctx.stroke();
    ctx.fillStyle = '#f472b6';
    ctx.fillText('SC = c = 4\u221A2 (P\u2083 = 12 cm\u00B2)', legX+38, ly);
    ly += 20;

    ctx.strokeStyle = '#34d399'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(legX+12, ly); ctx.lineTo(legX+32, ly); ctx.stroke();
    ctx.fillStyle = '#34d399';
    ctx.fillText('Ivice osnove ABC', legX+38, ly);
    ly += 20;

    ctx.fillStyle = '#4ade80';
    ctx.font = 'bold 12px Segoe UI, sans-serif';
    ctx.fillText('V = 8\u221A2 \u2248 11,31 cm\u00B3', legX + 12, ly);
  }

  draw3d();

  // Mouse drag for rotation
  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }

  canvas.addEventListener('mousedown', function(e) {
    dragging = true;
    const p = getPos(e);
    lastMx = p.x;
    lastMy = p.y;
  });

  canvas.addEventListener('mousemove', function(e) {
    if (!dragging) return;
    const p = getPos(e);
    const dx = p.x - lastMx;
    const dy = p.y - lastMy;
    angleY += dx * 0.008;
    angleX += dy * 0.008;
    lastMx = p.x;
    lastMy = p.y;
    draw3d();
  });

  canvas.addEventListener('mouseup', function() { dragging = false; });
  canvas.addEventListener('mouseleave', function() { dragging = false; });

  // Touch support
  canvas.addEventListener('touchstart', function(e) {
    e.preventDefault();
    dragging = true;
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    lastMx = t.clientX - rect.left;
    lastMy = t.clientY - rect.top;
  });

  canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
    if (!dragging) return;
    const t = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const px = t.clientX - rect.left;
    const py = t.clientY - rect.top;
    const dx = px - lastMx;
    const dy = py - lastMy;
    angleY += dx * 0.008;
    angleX += dy * 0.008;
    lastMx = px;
    lastMy = py;
    draw3d();
  });

  canvas.addEventListener('touchend', function() { dragging = false; });
})();
</script>
</body>
</html>
<!--BRAINSPARK_META
{
  "title": "Zapremina trostrane piramide sa pravouglim bočnim stranama",
  "subject": "math",
  "unit": "geometry",
  "topic_tags": ["stereometrija", "trostrana piramida", "tetraedar", "zapremina", "pravougli trougao", "uzajamno normalne ivice"]
}
BRAINSPARK_META-->