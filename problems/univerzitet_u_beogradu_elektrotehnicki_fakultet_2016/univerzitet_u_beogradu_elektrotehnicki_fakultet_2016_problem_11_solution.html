<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ortocentar trougla u koordinatnom sistemu</title>
<script type="text/info" id="logic-scratchpad">
Problem: Temena trougla su A(-8, 4), B(-2, 1), C(1, -3). Ortocentar H(x0, y0). Naći y0 - x0.

Ortocentar je presek visina trougla. Visina je prava kroz teme, normalna na naspramnu stranicu.

Korak 1: Visina iz A na stranicu BC
  Vektor BC = C - B = (1-(-2), -3-1) = (3, -4)
  Nagib BC: k_BC = -4/3
  Nagib visine iz A (normala na BC): k_hA = 3/4  (negativni recipročni)
  Jednačina prave kroz A(-8, 4) sa nagibom 3/4:
    y - 4 = (3/4)(x - (-8))
    y - 4 = (3/4)(x + 8)
    y = (3/4)x + 6 + 4
    y = (3/4)x + 10         ... (1)

Korak 2: Visina iz B na stranicu AC
  Vektor AC = C - A = (1-(-8), -3-4) = (9, -7)
  Nagib AC: k_AC = -7/9
  Nagib visine iz B (normala na AC): k_hB = 9/7
  Jednačina prave kroz B(-2, 1) sa nagibom 9/7:
    y - 1 = (9/7)(x - (-2))
    y - 1 = (9/7)(x + 2)
    y = (9/7)x + 18/7 + 1
    y = (9/7)x + 18/7 + 7/7
    y = (9/7)x + 25/7       ... (2)

Korak 3: Presek pravih (1) i (2)
  (3/4)x + 10 = (9/7)x + 25/7
  Množimo sa 28 (NZS od 4 i 7):
  28 * (3/4)x + 28 * 10 = 28 * (9/7)x + 28 * (25/7)
  21x + 280 = 36x + 100
  280 - 100 = 36x - 21x
  180 = 15x
  x = 12

  Iz (1): y = (3/4)(12) + 10 = 9 + 10 = 19

  Dakle H(12, 19), x0 = 12, y0 = 19.

Korak 4: Provera sa visinom iz C na AB
  Vektor AB = B - A = (-2-(-8), 1-4) = (6, -3)
  Nagib AB: k_AB = -3/6 = -1/2
  Nagib visine iz C (normala na AB): k_hC = 2
  Jednačina prave kroz C(1, -3) sa nagibom 2:
    y - (-3) = 2(x - 1)
    y + 3 = 2x - 2
    y = 2x - 5              ... (3)

  Za x = 12: y = 2(12) - 5 = 24 - 5 = 19  ✓  Tačka H(12, 19) leži i na trećoj visini.

Korak 5: Rezultat
  y0 - x0 = 19 - 12 = 7

Odgovor: (A) 7

Provera ortogonalnosti:
  AH · BC = (12-(-8), 19-4) · (3, -4) = (20, 15) · (3, -4) = 60 - 60 = 0  ✓
  BH · AC = (12-(-2), 19-1) · (9, -7) = (14, 18) · (9, -7) = 126 - 126 = 0  ✓
  CH · AB = (12-1, 19-(-3)) · (6, -3) = (11, 22) · (6, -3) = 66 - 66 = 0  ✓
</script>
<script>
MathJax = {
  tex: {
    inlineMath: [['\\(', '\\)'], ['$', '$']],
    displayMath: [['\\[', '\\]']]
  },
  svg: { fontCache: 'global' }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0f172a;
  color: #e2e8f0;
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  line-height: 1.7;
  padding: 20px;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

h1 {
  font-size: 2.2rem;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 8px;
  line-height: 1.3;
}

.subtitle {
  color: #94a3b8;
  font-size: 1.1rem;
  margin-bottom: 32px;
}

.card {
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 14px;
  padding: 24px;
  margin-bottom: 24px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.35);
}

.card h2 {
  color: #60a5fa;
  font-size: 1.4rem;
  margin-bottom: 16px;
}

.card h3 {
  color: #e2e8f0;
  font-size: 1.15rem;
  margin-bottom: 10px;
}

.highlight {
  color: #f472b6;
  font-weight: 600;
}

.math-box {
  background: rgba(56,189,248,0.08);
  border: 1px solid rgba(56,189,248,0.15);
  border-radius: 8px;
  padding: 14px 18px;
  margin: 12px 0;
  font-family: 'Courier New', monospace;
  font-size: 1.05rem;
  overflow-x: auto;
}

.given-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 16px;
}

.given-item {
  background: rgba(96,165,250,0.08);
  border: 1px solid rgba(96,165,250,0.18);
  border-radius: 10px;
  padding: 12px 18px;
  min-width: 80px;
  text-align: center;
  transition: transform 0.2s, border-color 0.2s;
}

.given-item:hover {
  transform: translateY(-2px);
}

.given-item .label {
  color: #94a3b8;
  font-size: 0.85rem;
  margin-bottom: 4px;
}

.given-item .value {
  color: #e2e8f0;
  font-size: 1.1rem;
  font-weight: 600;
}

.answer-option {
  cursor: default;
}

/* Plan card */
.plan-card {
  border-left: 3px solid #a78bfa;
}

.plan-card h2 {
  color: #a78bfa;
}

/* Details/collapsible */
details {
  margin: 15px 0;
  background: rgba(167,139,250,0.06);
  border: 1px solid rgba(167,139,250,0.15);
  border-radius: 10px;
  padding: 14px 18px;
}

details summary {
  cursor: pointer;
  color: #a78bfa;
  font-weight: 600;
  font-size: 1.05rem;
  user-select: none;
}

details summary:hover {
  color: #c4b5fd;
}

details[open] summary {
  margin-bottom: 12px;
}

details ul {
  list-style: none;
  padding-left: 0;
}

details li {
  padding: 6px 0;
  border-bottom: 1px solid rgba(51,65,85,0.5);
  color: #e2e8f0;
}

details li:last-child {
  border-bottom: none;
}

/* Canvas card */
.canvas-card {
  text-align: center;
}

.canvas-card canvas {
  width: 100%;
  max-width: 700px;
  border-radius: 10px;
  border: 1px solid #334155;
  touch-action: none;
}

.drag-hint {
  color: #64748b;
  font-size: 0.85rem;
  margin-top: 8px;
  font-style: italic;
}

/* Steps */
.step {
  display: flex;
  gap: 16px;
  padding: 16px;
  border-radius: 10px;
  margin-bottom: 14px;
  border-left: 3px solid transparent;
  transition: border-color 0.2s, background 0.2s;
  cursor: pointer;
}

.step:hover, .step.active {
  border-left-color: #4ade80;
  background: rgba(74,222,128,0.04);
}

.step-badge {
  flex-shrink: 0;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  color: #fff;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.95rem;
}

.step-content {
  flex: 1;
}

.step-content p {
  color: #94a3b8;
  margin-top: 6px;
}

/* Checkpoint */
.checkpoint {
  background: rgba(52,211,153,0.06);
  border: 1px solid rgba(52,211,153,0.18);
}

.checkpoint summary {
  color: #34d399;
}

/* Key insight */
.insight-card {
  background: linear-gradient(135deg, rgba(96,165,250,0.1), rgba(167,139,250,0.1));
  border: 1px solid rgba(167,139,250,0.25);
}

.insight-card h2 {
  color: #a78bfa;
}

/* Final answer */
.final-answer {
  border: 2px solid rgba(74,222,128,0.3);
  background: linear-gradient(135deg, rgba(74,222,128,0.06), rgba(52,211,153,0.04));
}

.final-answer h2 {
  color: #4ade80;
}

.answer-big {
  font-size: 1.6rem;
  font-weight: 700;
  color: #4ade80;
  text-align: center;
  margin: 20px 0;
}

.options-row {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  justify-content: center;
  margin: 16px 0;
}

.option-box {
  padding: 10px 20px;
  border-radius: 10px;
  border: 2px solid #334155;
  background: #1e293b;
  text-align: center;
  min-width: 90px;
  transition: transform 0.2s;
}

.option-box.correct {
  border-color: #4ade80;
  background: rgba(74,222,128,0.1);
  transform: scale(1.05);
}

.option-box .opt-label {
  color: #94a3b8;
  font-size: 0.85rem;
}

.option-box .opt-value {
  font-size: 1.15rem;
  font-weight: 600;
  color: #e2e8f0;
}

.option-box.correct .opt-value {
  color: #4ade80;
}

.verification {
  color: #94a3b8;
  font-size: 0.95rem;
  margin-top: 14px;
  padding-top: 14px;
  border-top: 1px solid #334155;
}

/* Pitfalls */
.pitfall-list {
  list-style: none;
  padding: 0;
}

.pitfall-list li {
  padding: 10px 14px;
  margin-bottom: 8px;
  background: rgba(224,148,104,0.06);
  border-left: 3px solid #e09468;
  border-radius: 0 8px 8px 0;
  color: #e2e8f0;
}

.pitfall-list li strong {
  color: #e09468;
}

/* Challenge */
.challenge-card {
  border: 1px solid rgba(244,114,182,0.2);
  background: rgba(244,114,182,0.04);
}

.challenge-card h2 {
  color: #f472b6;
}

@media (max-width: 700px) {
  h1 { font-size: 1.6rem; }
  .card { padding: 16px; }
  .step { flex-direction: column; gap: 10px; }
  .given-grid { flex-direction: column; }
  .options-row { flex-direction: column; align-items: center; }
}
</style>
</head>
<body>
<div class="container">

  <h1>Ortocentar trougla u koordinatnom sistemu</h1>
  <p class="subtitle">Analitička geometrija: visine trougla, normala na pravu, presek pravih</p>

  <!-- Problem Statement -->
  <div class="card problem-statement">
    <h2>Postavka zadatka</h2>
    <p>Ako su temena trougla tačke \(A(-8,\, 4)\), \(B(-2,\, 1)\) i \(C(1,\, -3)\), a ortocentar \(H(x_0,\, y_0)\), tada je vrednost razlike \(y_0 - x_0\) jednaka:</p>

    <div class="given-grid" style="margin-bottom: 18px;">
      <div class="given-item">
        <div class="label">Teme A</div>
        <div class="value">\((-8,\, 4)\)</div>
      </div>
      <div class="given-item">
        <div class="label">Teme B</div>
        <div class="value">\((-2,\, 1)\)</div>
      </div>
      <div class="given-item">
        <div class="label">Teme C</div>
        <div class="value">\((1,\, -3)\)</div>
      </div>
      <div class="given-item">
        <div class="label">Ortocentar</div>
        <div class="value">\(H(x_0,\, y_0)\)</div>
      </div>
    </div>

    <div class="given-grid">
      <div class="given-item answer-option" data-option="A">
        <div class="label">(A)</div>
        <div class="value">\(7\)</div>
      </div>
      <div class="given-item answer-option" data-option="B">
        <div class="label">(B)</div>
        <div class="value">\(6\)</div>
      </div>
      <div class="given-item answer-option" data-option="C">
        <div class="label">(C)</div>
        <div class="value">\(5\)</div>
      </div>
      <div class="given-item answer-option" data-option="D">
        <div class="label">(D)</div>
        <div class="value">\(4\)</div>
      </div>
      <div class="given-item answer-option" data-option="E">
        <div class="label">(E)</div>
        <div class="value">\(8\)</div>
      </div>
    </div>
  </div>

  <!-- Plan -->
  <div class="card plan-card">
    <h2>Plan rešavanja</h2>
    <p>Ortocentar je presečna tačka visina trougla. Odredićemo jednačine dve visine (svaka prolazi kroz jedno teme i normalna je na naspramnu stranicu), naći njihov presek, i izračunati \(y_0 - x_0\). Treću visinu koristimo za proveru.</p>
  </div>

  <!-- Theory Refresher -->
  <details>
    <summary>Ključne formule i teoreme</summary>
    <ul>
      <li><strong>Nagib duži:</strong> Za tačke \(P(x_1, y_1)\) i \(Q(x_2, y_2)\), nagib je \(\displaystyle k = \frac{y_2 - y_1}{x_2 - x_1}\).</li>
      <li><strong>Uslov normalnosti:</strong> Dve prave sa nagibima \(k_1\) i \(k_2\) su međusobno normalne ako i samo ako važi \(k_1 \cdot k_2 = -1\), tj. \(k_2 = -\dfrac{1}{k_1}\).</li>
      <li><strong>Jednačina prave kroz tačku:</strong> Prava kroz tačku \((x_1, y_1)\) sa nagibom \(k\) glasi: \(y - y_1 = k(x - x_1)\).</li>
      <li><strong>Ortocentar:</strong> Presečna tačka tri visine trougla. Visina trougla je prava povučena iz temena normalno na naspramnu stranicu.</li>
    </ul>
  </details>

  <!-- Canvas Visualization -->
  <div class="card canvas-card">
    <h2>Interaktivni dijagram: Trougao, visine i ortocentar</h2>
    <p style="color:#94a3b8; margin-bottom: 14px;">Prikaz trougla \(ABC\), tri visine (isprekidane linije) i ortocentra \(H\)</p>
    <canvas id="viz-canvas" width="700" height="600"></canvas>
    <p class="drag-hint">Pomerajte tačke A, B i C da vidite kako se menja položaj ortocentra H</p>
  </div>

  <!-- Step-by-step solution -->
  <div class="card">
    <h2>Rešenje korak po korak</h2>

    <div class="step" id="step-1">
      <div class="step-badge">1</div>
      <div class="step-content">
        <h3>Nagib stranice \(BC\)</h3>
        <p>Računamo nagib stranice \(BC\) koristeći koordinate tačaka \(B(-2, 1)\) i \(C(1, -3)\):</p>
        <div class="math-box">
          \[ k_{BC} = \frac{y_C - y_B}{x_C - x_B} = \frac{-3 - 1}{1 - (-2)} = \frac{-4}{3} \]
        </div>
      </div>
    </div>

    <div class="step" id="step-2">
      <div class="step-badge">2</div>
      <div class="step-content">
        <h3>Jednačina visine iz temena \(A\) na stranicu \(BC\)</h3>
        <p>Visina iz \(A\) je <span class="highlight">normalna na \(BC\)</span>, pa je njen nagib negativni recipročni nagib stranice \(BC\):</p>
        <div class="math-box">
          \[ k_{h_A} = -\frac{1}{k_{BC}} = -\frac{1}{-\frac{4}{3}} = \frac{3}{4} \]
        </div>
        <p>Jednačina prave kroz \(A(-8, 4)\) sa nagibom \(\frac{3}{4}\):</p>
        <div class="math-box">
          \[ y - 4 = \frac{3}{4}(x - (-8)) = \frac{3}{4}(x + 8) \]
        </div>
        <p>Raspisujemo:</p>
        <div class="math-box">
          \[ y = \frac{3}{4}x + 6 + 4 = \frac{3}{4}x + 10 \quad \cdots (1) \]
        </div>
      </div>
    </div>

    <details class="checkpoint">
      <summary>Proveri se: Koliki je nagib visine iz temena A?</summary>
      <p>Nagib stranice \(BC\) je \(-\frac{4}{3}\). Nagib visine iz \(A\) (normala na \(BC\)) je \(-\frac{1}{-4/3} = \frac{3}{4}\). Koristimo uslov normalnosti \(k_1 \cdot k_2 = -1\): zaista \(-\frac{4}{3} \cdot \frac{3}{4} = -1\).</p>
    </details>

    <div class="step" id="step-3">
      <div class="step-badge">3</div>
      <div class="step-content">
        <h3>Nagib stranice \(AC\)</h3>
        <p>Računamo nagib stranice \(AC\) koristeći koordinate tačaka \(A(-8, 4)\) i \(C(1, -3)\):</p>
        <div class="math-box">
          \[ k_{AC} = \frac{y_C - y_A}{x_C - x_A} = \frac{-3 - 4}{1 - (-8)} = \frac{-7}{9} \]
        </div>
      </div>
    </div>

    <div class="step" id="step-4">
      <div class="step-badge">4</div>
      <div class="step-content">
        <h3>Jednačina visine iz temena \(B\) na stranicu \(AC\)</h3>
        <p>Visina iz \(B\) je <span class="highlight">normalna na \(AC\)</span>:</p>
        <div class="math-box">
          \[ k_{h_B} = -\frac{1}{k_{AC}} = -\frac{1}{-\frac{7}{9}} = \frac{9}{7} \]
        </div>
        <p>Jednačina prave kroz \(B(-2, 1)\) sa nagibom \(\frac{9}{7}\):</p>
        <div class="math-box">
          \[ y - 1 = \frac{9}{7}(x - (-2)) = \frac{9}{7}(x + 2) \]
        </div>
        <p>Raspisujemo:</p>
        <div class="math-box">
          \[ y = \frac{9}{7}x + \frac{18}{7} + \frac{7}{7} = \frac{9}{7}x + \frac{25}{7} \quad \cdots (2) \]
        </div>
      </div>
    </div>

    <div class="step" id="step-5">
      <div class="step-badge">5</div>
      <div class="step-content">
        <h3>Presek visina: nalaženje \(x_0\)</h3>
        <p>Izjednačavamo jednačine (1) i (2):</p>
        <div class="math-box">
          \[ \frac{3}{4}x + 10 = \frac{9}{7}x + \frac{25}{7} \]
        </div>
        <p>Množimo celu jednačinu sa <span class="highlight">28</span> (NZS brojeva 4 i 7) da eliminišemo razlomke:</p>
        <div class="math-box">
          \[ 21x + 280 = 36x + 100 \]
        </div>
        <p>Prebacujemo \(x\) na jednu stranu:</p>
        <div class="math-box">
          \[ 280 - 100 = 36x - 21x \]
          \[ 180 = 15x \]
          \[ x_0 = 12 \]
        </div>
      </div>
    </div>

    <div class="step" id="step-6">
      <div class="step-badge">6</div>
      <div class="step-content">
        <h3>Nalaženje \(y_0\)</h3>
        <p>Zamenjujemo \(x_0 = 12\) u jednačinu (1):</p>
        <div class="math-box">
          \[ y_0 = \frac{3}{4} \cdot 12 + 10 = 9 + 10 = 19 \]
        </div>
        <p>Dakle, ortocentar je \(H(12, 19)\).</p>
      </div>
    </div>

    <details class="checkpoint">
      <summary>Proveri se: Da li \(H(12, 19)\) leži i na visini iz \(C\)?</summary>
      <p>Nagib stranice \(AB\): \(k_{AB} = \frac{1-4}{-2-(-8)} = \frac{-3}{6} = -\frac{1}{2}\). Nagib visine iz \(C\): \(k_{h_C} = 2\). Jednačina: \(y + 3 = 2(x - 1)\), tj. \(y = 2x - 5\). Za \(x = 12\): \(y = 2 \cdot 12 - 5 = 19\). Tačno! Tačka \(H(12, 19)\) leži na sve tri visine.</p>
    </details>

    <div class="step" id="step-7">
      <div class="step-badge">7</div>
      <div class="step-content">
        <h3>Izračunavanje tražene razlike</h3>
        <p>Sada možemo izračunati:</p>
        <div class="math-box">
          \[ y_0 - x_0 = 19 - 12 = 7 \]
        </div>
      </div>
    </div>

    <div class="step" id="step-8">
      <div class="step-badge">8</div>
      <div class="step-content">
        <h3>Provera ortogonalnosti (skalarni proizvod)</h3>
        <p>Potvrđujemo da je svaka visina zaista normalna na naspramnu stranicu pomoću <span class="highlight">skalarnog proizvoda</span>:</p>
        <div class="math-box">
          \[ \vec{AH} \cdot \vec{BC} = (20,\, 15) \cdot (3,\, -4) = 60 - 60 = 0 \;\checkmark \]
        </div>
        <div class="math-box">
          \[ \vec{BH} \cdot \vec{AC} = (14,\, 18) \cdot (9,\, -7) = 126 - 126 = 0 \;\checkmark \]
        </div>
        <div class="math-box">
          \[ \vec{CH} \cdot \vec{AB} = (11,\, 22) \cdot (6,\, -3) = 66 - 66 = 0 \;\checkmark \]
        </div>
        <p>Svi skalarni proizvodi su nula, čime je potvrđeno da je \(H(12, 19)\) zaista ortocentar.</p>
      </div>
    </div>

    <details class="checkpoint">
      <summary>Proveri se: Zašto skalarni proizvod nula znači normalnost?</summary>
      <p>Dva vektora su međusobno normalna (grade ugao od \(90°\)) ako i samo ako je njihov skalarni proizvod jednak nuli: \(\vec{u} \cdot \vec{v} = u_1 v_1 + u_2 v_2 = 0\). Ovo sledi iz formule \(\vec{u} \cdot \vec{v} = |\vec{u}||\vec{v}|\cos\theta\), jer je \(\cos 90° = 0\).</p>
    </details>
  </div>

  <!-- Key Insight -->
  <div class="card insight-card">
    <h2>Ključni uvid</h2>
    <p>Ortocentar trougla sa temenima \(A(-8, 4)\), \(B(-2, 1)\), \(C(1, -3)\) se nalazi daleko van samog trougla, u tački \(H(12, 19)\). Ovo je karakteristično za <strong>tupougli trougao</strong> &mdash; kada je jedan ugao tupi, ortocentar leži izvan trougla, na strani suprotnoj od tupog ugla. Što je ugao tupiji, ortocentar je dalje od trougla.</p>
    <div class="math-box" style="text-align: center; font-size: 1.2rem;">
      \[ H(12,\, 19) \implies y_0 - x_0 = 19 - 12 = \color{#4ade80}{7} \]
    </div>
  </div>

  <!-- Final Answer -->
  <div class="card final-answer">
    <h2>Konačan odgovor</h2>
    <div class="answer-big">\(y_0 - x_0 = 7\)</div>

    <div class="options-row">
      <div class="option-box correct">
        <div class="opt-label">(A)</div>
        <div class="opt-value">\(7\)</div>
      </div>
      <div class="option-box">
        <div class="opt-label">(B)</div>
        <div class="opt-value">\(6\)</div>
      </div>
      <div class="option-box">
        <div class="opt-label">(C)</div>
        <div class="opt-value">\(5\)</div>
      </div>
      <div class="option-box">
        <div class="opt-label">(D)</div>
        <div class="opt-value">\(4\)</div>
      </div>
      <div class="option-box">
        <div class="opt-label">(E)</div>
        <div class="opt-value">\(8\)</div>
      </div>
    </div>

    <p class="verification"><strong>Provera:</strong> Ortocentar \(H(12, 19)\) je potvrđen na tri načina: leži na preseku sve tri visine, i skalarni proizvod svakog vektora visine sa odgovarajućom stranicom iznosi nula. Vrednost \(y_0 - x_0 = 19 - 12 = 7\).</p>
  </div>

  <!-- Common Pitfalls -->
  <div class="card">
    <h2>Česte greške</h2>
    <ul class="pitfall-list">
      <li><strong>Zamena nagiba i normalnog nagiba:</strong> Nagib visine iz temena \(A\) je normala na stranicu \(BC\), a ne sam nagib stranice \(BC\). Mnogi studenti zaborave da primene uslov normalnosti \(k_1 \cdot k_2 = -1\) i koriste direktno nagib stranice.</li>
      <li><strong>Greška u znaku:</strong> Koordinate tačaka uključuju negativne brojeve (\(-8\), \(-2\), \(-3\)). Veoma je lako napraviti grešku u znaku pri računanju razlika \(x_2 - x_1\) ili pri množenju, naročito kada se formira jednačina prave. Posebno paziti na \(x - (-8) = x + 8\).</li>
    </ul>
  </div>

  <!-- Optional Challenge -->
  <div class="card challenge-card">
    <h2>Dodatni izazov</h2>
    <p>Nađite koordinate težišta \(T\) i centra opisanog kruga \(O\) istog trougla. Zatim proverite da sve tri tačke \(H\), \(T\) i \(O\) leže na jednoj pravoj (Ojlerova prava) i da važi \(\overrightarrow{OH} = 3\,\overrightarrow{OT}\).</p>
    <details>
      <summary>Pomoć</summary>
      <p>Težište se računa kao \(T = \left(\frac{x_A + x_B + x_C}{3},\, \frac{y_A + y_B + y_C}{3}\right) = \left(-3,\, \frac{2}{3}\right)\). Za centar opisanog kruga treba rešiti sistem dve jednačine simetrala duži (npr. simetrala \(AB\) i simetrala \(BC\)). Zatim proverite da tačke \(O\), \(T\), \(H\) leže na istoj pravoj.</p>
    </details>
  </div>

</div>

<script>
(() => {
  const canvas = document.getElementById('viz-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  // Draggable points (math coordinates, Y-up)
  let points = {
    A: { x: -8, y: 4 },
    B: { x: -2, y: 1 },
    C: { x: 1, y: -3 }
  };

  // Coordinate transformation: math (Y-up) to canvas (Y-down)
  // We need to fit the triangle AND orthocenter in view
  const padding = 60;
  let scale, originX, originY;

  function computeTransform() {
    // Compute orthocenter to know bounds
    const orth = computeOrthocenter(points.A, points.B, points.C);
    const allPts = [points.A, points.B, points.C];
    if (orth) allPts.push(orth);

    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (let i = 0; i < allPts.length; i++) {
      if (allPts[i].x < minX) minX = allPts[i].x;
      if (allPts[i].x > maxX) maxX = allPts[i].x;
      if (allPts[i].y < minY) minY = allPts[i].y;
      if (allPts[i].y > maxY) maxY = allPts[i].y;
    }

    // Add margin
    const marginFrac = 0.15;
    const rangeX = maxX - minX || 1;
    const rangeY = maxY - minY || 1;
    minX -= rangeX * marginFrac;
    maxX += rangeX * marginFrac;
    minY -= rangeY * marginFrac;
    maxY += rangeY * marginFrac;

    const scaleX = (W - 2 * padding) / (maxX - minX);
    const scaleY = (H - 2 * padding) / (maxY - minY);
    scale = Math.min(scaleX, scaleY);

    const midX = (minX + maxX) / 2;
    const midY = (minY + maxY) / 2;
    originX = W / 2 - midX * scale;
    originY = H / 2 + midY * scale;
  }

  function toCanvas(x, y) {
    return { x: originX + x * scale, y: originY - y * scale };
  }

  function toMath(cx, cy) {
    return { x: (cx - originX) / scale, y: (originY - cy) / scale };
  }

  function computeOrthocenter(A, B, C) {
    // Altitude from A perpendicular to BC
    var dxBC = C.x - B.x;
    var dyBC = C.y - B.y;
    // Altitude from B perpendicular to AC
    var dxAC = C.x - A.x;
    var dyAC = C.y - A.y;

    // Altitude from A: direction perpendicular to BC is (dyBC, -dxBC)
    // Parametric: P = A + t*(dyBC, -dxBC)
    // Altitude from B: direction perpendicular to AC is (dyAC, -dxAC)
    // Parametric: Q = B + s*(dyAC, -dxAC)

    // Solve: A + t*d1 = B + s*d2
    // A.x + t*dyBC = B.x + s*dyAC
    // A.y + t*(-dxBC) = B.y + s*(-dxAC)

    var d1x = dyBC, d1y = -dxBC;
    var d2x = dyAC, d2y = -dxAC;

    var det = d1x * d2y - d1y * d2x;
    if (Math.abs(det) < 1e-10) return null; // degenerate

    var bx = B.x - A.x;
    var by = B.y - A.y;

    var t = (bx * d2y - by * d2x) / det;

    return {
      x: A.x + t * d1x,
      y: A.y + t * d1y
    };
  }

  // Compute foot of altitude: foot of perpendicular from P to line through Q and R
  function footOfAltitude(P, Q, R) {
    var dx = R.x - Q.x;
    var dy = R.y - Q.y;
    var t = ((P.x - Q.x) * dx + (P.y - Q.y) * dy) / (dx * dx + dy * dy);
    return { x: Q.x + t * dx, y: Q.y + t * dy };
  }

  function drawRightAngleMarker(foot, dir1, dir2, size) {
    // dir1 and dir2 are unit vectors from foot towards respective directions
    var p1 = { x: foot.x + dir1.x * size, y: foot.y + dir1.y * size };
    var p2 = { x: foot.x + dir2.x * size, y: foot.y + dir2.y * size };
    var corner = { x: foot.x + dir1.x * size + dir2.x * size, y: foot.y + dir1.y * size + dir2.y * size };

    var cp1 = toCanvas(p1.x, p1.y);
    var cCorner = toCanvas(corner.x, corner.y);
    var cp2 = toCanvas(p2.x, p2.y);

    ctx.strokeStyle = '#34d399';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(cp1.x, cp1.y);
    ctx.lineTo(cCorner.x, cCorner.y);
    ctx.lineTo(cp2.x, cp2.y);
    ctx.stroke();
  }

  function normalize(v) {
    var len = Math.sqrt(v.x * v.x + v.y * v.y);
    if (len < 1e-10) return { x: 0, y: 0 };
    return { x: v.x / len, y: v.y / len };
  }

  function draw() {
    computeTransform();

    var A = points.A, B = points.B, C = points.C;
    var orth = computeOrthocenter(A, B, C);

    // Background
    ctx.fillStyle = '#0c1222';
    ctx.fillRect(0, 0, W, H);

    // Grid
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    // Determine grid range
    var topLeft = toMath(0, 0);
    var bottomRight = toMath(W, H);
    var gridMinX = Math.floor(Math.min(topLeft.x, bottomRight.x)) - 1;
    var gridMaxX = Math.ceil(Math.max(topLeft.x, bottomRight.x)) + 1;
    var gridMinY = Math.floor(Math.min(topLeft.y, bottomRight.y)) - 1;
    var gridMaxY = Math.ceil(Math.max(topLeft.y, bottomRight.y)) + 1;

    // Determine grid step to avoid too many lines
    var gridRange = Math.max(gridMaxX - gridMinX, gridMaxY - gridMinY);
    var gridStep = 1;
    if (gridRange > 40) gridStep = 5;
    else if (gridRange > 20) gridStep = 2;

    for (var gx = Math.ceil(gridMinX / gridStep) * gridStep; gx <= gridMaxX; gx += gridStep) {
      var p1 = toCanvas(gx, gridMinY);
      var p2 = toCanvas(gx, gridMaxY);
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }
    for (var gy = Math.ceil(gridMinY / gridStep) * gridStep; gy <= gridMaxY; gy += gridStep) {
      var p1g = toCanvas(gridMinX, gy);
      var p2g = toCanvas(gridMaxX, gy);
      ctx.beginPath();
      ctx.moveTo(p1g.x, p1g.y);
      ctx.lineTo(p2g.x, p2g.y);
      ctx.stroke();
    }

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1.5;
    // X-axis
    var axYp1 = toCanvas(gridMinX, 0);
    var axYp2 = toCanvas(gridMaxX, 0);
    ctx.beginPath();
    ctx.moveTo(axYp1.x, axYp1.y);
    ctx.lineTo(axYp2.x, axYp2.y);
    ctx.stroke();
    // Y-axis
    var axXp1 = toCanvas(0, gridMinY);
    var axXp2 = toCanvas(0, gridMaxY);
    ctx.beginPath();
    ctx.moveTo(axXp1.x, axXp1.y);
    ctx.lineTo(axXp2.x, axXp2.y);
    ctx.stroke();

    // Axis tick labels
    ctx.fillStyle = '#64748b';
    ctx.font = '11px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'center';
    for (var tx = Math.ceil(gridMinX / gridStep) * gridStep; tx <= gridMaxX; tx += gridStep) {
      if (tx === 0) continue;
      var tp = toCanvas(tx, 0);
      ctx.fillText(String(tx), tp.x, tp.y + 14);
    }
    ctx.textAlign = 'right';
    for (var ty = Math.ceil(gridMinY / gridStep) * gridStep; ty <= gridMaxY; ty += gridStep) {
      if (ty === 0) continue;
      var tpy = toCanvas(0, ty);
      ctx.fillText(String(ty), tpy.x - 6, tpy.y + 4);
    }

    // Triangle sides
    var cA = toCanvas(A.x, A.y);
    var cB = toCanvas(B.x, B.y);
    var cC = toCanvas(C.x, C.y);

    ctx.strokeStyle = '#60a5fa';
    ctx.lineWidth = 2.5;
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(cA.x, cA.y);
    ctx.lineTo(cB.x, cB.y);
    ctx.lineTo(cC.x, cC.y);
    ctx.closePath();
    ctx.stroke();

    // Fill triangle lightly
    ctx.fillStyle = 'rgba(96, 165, 250, 0.06)';
    ctx.fill();

    if (orth) {
      // Feet of altitudes
      var footA = footOfAltitude(A, B, C);
      var footB = footOfAltitude(B, A, C);
      var footC = footOfAltitude(C, A, B);

      // Draw altitudes as dashed lines from vertex through foot, extended to orthocenter
      ctx.setLineDash([6, 4]);
      ctx.lineWidth = 1.5;

      // Altitude from A
      ctx.strokeStyle = '#f472b6';
      ctx.beginPath();
      var cFA = toCanvas(footA.x, footA.y);
      ctx.moveTo(cA.x, cA.y);
      ctx.lineTo(cFA.x, cFA.y);
      ctx.stroke();

      // Altitude from B
      ctx.strokeStyle = '#a78bfa';
      ctx.beginPath();
      var cFB = toCanvas(footB.x, footB.y);
      ctx.moveTo(cB.x, cB.y);
      ctx.lineTo(cFB.x, cFB.y);
      ctx.stroke();

      // Altitude from C
      ctx.strokeStyle = '#38bdf8';
      ctx.beginPath();
      var cFC = toCanvas(footC.x, footC.y);
      ctx.moveTo(cC.x, cC.y);
      ctx.lineTo(cFC.x, cFC.y);
      ctx.stroke();

      ctx.setLineDash([]);

      // Extended altitude lines from vertex through orthocenter (dotted)
      ctx.setLineDash([3, 5]);
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.4;

      var cH = toCanvas(orth.x, orth.y);

      ctx.strokeStyle = '#f472b6';
      ctx.beginPath();
      ctx.moveTo(cFA.x, cFA.y);
      ctx.lineTo(cH.x, cH.y);
      ctx.stroke();

      ctx.strokeStyle = '#a78bfa';
      ctx.beginPath();
      ctx.moveTo(cFB.x, cFB.y);
      ctx.lineTo(cH.x, cH.y);
      ctx.stroke();

      ctx.strokeStyle = '#38bdf8';
      ctx.beginPath();
      ctx.moveTo(cFC.x, cFC.y);
      ctx.lineTo(cH.x, cH.y);
      ctx.stroke();

      ctx.globalAlpha = 1.0;
      ctx.setLineDash([]);

      // Right angle markers at feet
      var markerSize = 0.6;

      // At footA: directions along BC and along altitude (A to footA)
      var dirBC = normalize({ x: C.x - B.x, y: C.y - B.y });
      var dirAfoot = normalize({ x: A.x - footA.x, y: A.y - footA.y });
      drawRightAngleMarker(footA, dirBC, dirAfoot, markerSize);

      // At footB
      var dirAC = normalize({ x: C.x - A.x, y: C.y - A.y });
      var dirBfoot = normalize({ x: B.x - footB.x, y: B.y - footB.y });
      drawRightAngleMarker(footB, dirAC, dirBfoot, markerSize);

      // At footC
      var dirAB = normalize({ x: B.x - A.x, y: B.y - A.y });
      var dirCfoot = normalize({ x: C.x - footC.x, y: C.y - footC.y });
      drawRightAngleMarker(footC, dirAB, dirCfoot, markerSize);

      // Draw orthocenter H
      ctx.beginPath();
      ctx.arc(cH.x, cH.y, 8, 0, 2 * Math.PI);
      ctx.fillStyle = '#4ade80';
      ctx.fill();
      ctx.strokeStyle = '#166534';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Glow around H
      var glow = ctx.createRadialGradient(cH.x, cH.y, 0, cH.x, cH.y, 25);
      glow.addColorStop(0, 'rgba(74, 222, 128, 0.3)');
      glow.addColorStop(1, 'rgba(74, 222, 128, 0)');
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(cH.x, cH.y, 25, 0, 2 * Math.PI);
      ctx.fill();

      // H label
      ctx.fillStyle = '#4ade80';
      ctx.font = 'bold 15px Segoe UI, system-ui, sans-serif';
      ctx.textAlign = 'left';
      var hLabel = 'H(' + Math.round(orth.x * 10) / 10 + ', ' + Math.round(orth.y * 10) / 10 + ')';
      ctx.fillText(hLabel, cH.x + 12, cH.y - 10);
    }

    // Draw vertex points
    var vertexColors = { A: '#f472b6', B: '#a78bfa', C: '#38bdf8' };
    var labels = ['A', 'B', 'C'];
    var pts = [A, B, C];
    var cPts = [cA, cB, cC];
    var labelOffsets = [
      { dx: -20, dy: -14 },
      { dx: -20, dy: 18 },
      { dx: 12, dy: 14 }
    ];

    for (var i = 0; i < 3; i++) {
      var col = vertexColors[labels[i]];
      var cp = cPts[i];

      // Point
      ctx.beginPath();
      ctx.arc(cp.x, cp.y, 7, 0, 2 * Math.PI);
      ctx.fillStyle = col;
      ctx.fill();
      ctx.strokeStyle = '#0f172a';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Label
      ctx.fillStyle = col;
      ctx.font = 'bold 14px Segoe UI, system-ui, sans-serif';
      ctx.textAlign = 'center';
      var lbl = labels[i] + '(' + pts[i].x + ', ' + pts[i].y + ')';
      ctx.fillText(lbl, cp.x + labelOffsets[i].dx, cp.y + labelOffsets[i].dy);
    }

    // Legend
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'left';
    var legendY = 24;
    var legendX = 14;

    ctx.fillStyle = '#60a5fa';
    ctx.fillRect(legendX, legendY - 8, 20, 3);
    ctx.fillStyle = '#94a3b8';
    ctx.fillText('Stranice trougla', legendX + 26, legendY);

    ctx.setLineDash([6, 4]);
    ctx.strokeStyle = '#f472b6';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(legendX, legendY + 14);
    ctx.lineTo(legendX + 20, legendY + 14);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#94a3b8';
    ctx.fillText('Visine (visina iz A, B, C)', legendX + 26, legendY + 18);

    ctx.fillStyle = '#4ade80';
    ctx.beginPath();
    ctx.arc(legendX + 10, legendY + 36, 5, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillStyle = '#94a3b8';
    ctx.fillText('Ortocentar H', legendX + 26, legendY + 40);
  }

  draw();

  // Drag interaction
  var dragging = null;
  var dragRadius = 15;

  function getPointerPos(e) {
    var rect = canvas.getBoundingClientRect();
    var scaleFactorX = W / rect.width;
    var scaleFactorY = H / rect.height;
    var clientX, clientY;
    if (e.touches) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    return {
      x: (clientX - rect.left) * scaleFactorX,
      y: (clientY - rect.top) * scaleFactorY
    };
  }

  function findClosest(pos) {
    var keys = ['A', 'B', 'C'];
    var closest = null;
    var minDist = Infinity;
    for (var i = 0; i < keys.length; i++) {
      var cp = toCanvas(points[keys[i]].x, points[keys[i]].y);
      var dx = pos.x - cp.x;
      var dy = pos.y - cp.y;
      var dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < minDist) {
        minDist = dist;
        closest = keys[i];
      }
    }
    if (minDist < dragRadius * 2) return closest;
    return null;
  }

  function onDown(e) {
    e.preventDefault();
    var pos = getPointerPos(e);
    dragging = findClosest(pos);
  }

  function onMove(e) {
    if (!dragging) return;
    e.preventDefault();
    var pos = getPointerPos(e);
    var mp = toMath(pos.x, pos.y);
    points[dragging].x = Math.round(mp.x * 2) / 2;
    points[dragging].y = Math.round(mp.y * 2) / 2;
    draw();
  }

  function onUp() {
    dragging = null;
  }

  canvas.addEventListener('mousedown', onDown);
  canvas.addEventListener('mousemove', onMove);
  canvas.addEventListener('mouseup', onUp);
  canvas.addEventListener('mouseleave', onUp);
  canvas.addEventListener('touchstart', onDown);
  canvas.addEventListener('touchmove', onMove);
  canvas.addEventListener('touchend', onUp);

  // Step click interactivity
  var steps = document.querySelectorAll('.step');
  steps.forEach(function(step) {
    step.addEventListener('click', function() {
      steps.forEach(function(s) { s.classList.remove('active'); });
      step.classList.add('active');
    });
  });
})();
</script>
</body>
</html>
<!--BRAINSPARK_META
{
  "title": "Ortocentar trougla u koordinatnom sistemu",
  "subject": "math",
  "unit": "geometry",
  "topic_tags": ["ortocentar", "visine trougla", "analitička geometrija", "koordinatni sistem", "normala na pravu", "presek pravih"]
}
BRAINSPARK_META-->