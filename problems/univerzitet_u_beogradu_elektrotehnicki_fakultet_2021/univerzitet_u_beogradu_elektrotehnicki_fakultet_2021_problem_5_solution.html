<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Zapremina kvadra na osnovu povrsina strana</title>

<script type="text/info" id="logic-scratchpad">
PROBLEM: A rectangular parallelepiped (cuboid) has face areas 12, 8, and 6 cm².
Find its volume.

Let sides be a, b, c.
The three distinct face areas are:
  ab = 12
  ac = 8
  bc = 6

STEP 1: Multiply all three equations together:
  (ab)(ac)(bc) = 12 * 8 * 6
  a²b²c² = 576
  (abc)² = 576

STEP 2: Take square root:
  abc = √576 = 24

STEP 3: Verify by finding individual sides:
  From abc = 24 and ab = 12: c = 24/12 = 2
  From abc = 24 and ac = 8:  b = 24/8 = 3
  From abc = 24 and bc = 6:  a = 24/6 = 4

  Check face areas: ab = 4*3 = 12 ✓, ac = 4*2 = 8 ✓, bc = 3*2 = 6 ✓
  Volume: abc = 4*3*2 = 24 ✓

ANSWER: (A) 24 cm³
</script>

<script>
MathJax = {
  tex: { inlineMath: [['\\(', '\\)'], ['$', '$']], displayMath: [['\\[', '\\]']] },
  svg: { fontCache: 'global' }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

<style>
*, *::before, *::after {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: #0f172a;
  color: #e2e8f0;
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  line-height: 1.7;
  padding: 1rem;
  min-height: 100vh;
}

.container {
  max-width: 800px;
  margin: 0 auto;
  padding: 1rem 0;
}

h1 {
  font-size: clamp(1.5rem, 4vw, 2.2rem);
  font-weight: 700;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-align: center;
  margin-bottom: 0.25rem;
}

.subtitle {
  text-align: center;
  color: #94a3b8;
  font-size: 1.05rem;
  margin-bottom: 2rem;
}

.card {
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 14px;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}

.card-title {
  font-size: 1.15rem;
  font-weight: 600;
  color: #60a5fa;
  margin-bottom: 0.75rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.card-title .icon {
  font-size: 1.3rem;
}

.problem-statement {
  background: #1e293b;
  border: 2px solid #a78bfa;
  border-radius: 14px;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
  font-size: 1.1rem;
}

.problem-statement .card-title {
  color: #a78bfa;
}

.options-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
  gap: 0.5rem;
  margin-top: 1rem;
}

.option {
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 8px;
  padding: 0.5rem 0.75rem;
  text-align: center;
  font-size: 1rem;
  transition: border-color 0.2s;
}

.option.correct {
  border-color: #4ade80;
  background: rgba(74, 222, 128, 0.1);
  color: #4ade80;
  font-weight: 600;
}

.plan-list {
  list-style: none;
  counter-reset: plan;
}

.plan-list li {
  counter-increment: plan;
  padding: 0.4rem 0 0.4rem 2.2rem;
  position: relative;
}

.plan-list li::before {
  content: counter(plan);
  position: absolute;
  left: 0;
  top: 0.4rem;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  color: #0f172a;
  width: 1.6rem;
  height: 1.6rem;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 0.85rem;
}

details {
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 14px;
  margin-bottom: 1.5rem;
}

details summary {
  padding: 1rem 1.5rem;
  cursor: pointer;
  font-weight: 600;
  color: #a78bfa;
  list-style: none;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

details summary::-webkit-details-marker { display: none; }

details summary::before {
  content: '\25B6';
  font-size: 0.75rem;
  transition: transform 0.2s;
}

details[open] summary::before {
  transform: rotate(90deg);
}

details .detail-content {
  padding: 0 1.5rem 1.5rem;
}

.step {
  border-left: 3px solid #334155;
  padding-left: 1.25rem;
  margin-bottom: 1.5rem;
  position: relative;
}

.step::before {
  content: '';
  position: absolute;
  left: -7px;
  top: 0;
  width: 11px;
  height: 11px;
  border-radius: 50%;
  background: #60a5fa;
}

.step-title {
  font-weight: 600;
  color: #60a5fa;
  margin-bottom: 0.4rem;
  font-size: 1.05rem;
}

.checkpoint {
  background: rgba(163, 130, 250, 0.1);
  border: 1px solid #a78bfa;
  border-radius: 10px;
  padding: 0.75rem 1rem;
  margin: 0.75rem 0;
  font-size: 0.95rem;
  color: #a78bfa;
}

.checkpoint-label {
  font-weight: 700;
  margin-right: 0.25rem;
}

.canvas-wrap {
  text-align: center;
  margin: 1rem 0;
}

canvas {
  border-radius: 12px;
  background: #0f172a;
  border: 1px solid #334155;
  max-width: 100%;
  touch-action: none;
}

.final-answer {
  background: rgba(74, 222, 128, 0.08);
  border: 2px solid #4ade80;
  border-radius: 14px;
  padding: 1.5rem;
  text-align: center;
  margin-bottom: 1.5rem;
}

.final-answer .label {
  font-size: 0.95rem;
  color: #94a3b8;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 0.5rem;
}

.final-answer .value {
  font-size: 1.6rem;
  font-weight: 700;
  color: #4ade80;
}

.insight-box {
  background: linear-gradient(135deg, rgba(96,165,250,0.1), rgba(167,139,250,0.1));
  border: 1px solid #60a5fa;
  border-radius: 14px;
  padding: 1.25rem 1.5rem;
  margin-bottom: 1.5rem;
}

.insight-box .card-title {
  color: #60a5fa;
}

.pitfall {
  background: rgba(244, 114, 182, 0.08);
  border: 1px solid #f472b6;
  border-radius: 10px;
  padding: 0.75rem 1rem;
  margin-bottom: 0.75rem;
}

.pitfall strong {
  color: #f472b6;
}

.challenge-box {
  background: rgba(52, 211, 153, 0.08);
  border: 1px dashed #34d399;
  border-radius: 14px;
  padding: 1.25rem 1.5rem;
  margin-bottom: 1rem;
}

.challenge-box .card-title {
  color: #34d399;
}

.muted {
  color: #94a3b8;
}

.highlight {
  color: #4ade80;
  font-weight: 600;
}

mjx-container {
  overflow-x: auto;
}

.canvas-controls {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-top: 0.75rem;
  flex-wrap: wrap;
}

.canvas-controls button {
  background: #334155;
  color: #e2e8f0;
  border: 1px solid #475569;
  border-radius: 8px;
  padding: 0.4rem 0.9rem;
  font-size: 0.85rem;
  cursor: pointer;
  transition: background 0.2s, border-color 0.2s;
  font-family: inherit;
}

.canvas-controls button:hover {
  background: #475569;
  border-color: #60a5fa;
}

.canvas-controls button.active {
  background: rgba(96, 165, 250, 0.2);
  border-color: #60a5fa;
  color: #60a5fa;
}

@media (max-width: 600px) {
  body { padding: 0.5rem; }
  .card, .problem-statement, details .detail-content, .final-answer,
  .insight-box, .challenge-box { padding: 1rem; }
  .options-grid { grid-template-columns: repeat(3, 1fr); }
}
</style>
</head>
<body>
<div class="container">

  <!-- TITLE -->
  <h1>Zapremina kvadra iz povrsina strana</h1>
  <p class="subtitle">Stereometrija &mdash; Kvadar</p>

  <!-- PROBLEM STATEMENT -->
  <div class="problem-statement">
    <div class="card-title"><span class="icon">&#128220;</span> Zadatak</div>
    <p>Ako su povrsine strana kvadra \(12\,\text{cm}^2\), \(8\,\text{cm}^2\) i \(6\,\text{cm}^2\), onda je njegova zapremina:</p>
    <div class="options-grid">
      <div class="option correct" data-option="A">A) \(24\,\text{cm}^3\)</div>
      <div class="option" data-option="B">B) \(96\,\text{cm}^3\)</div>
      <div class="option" data-option="C">C) \(48\,\text{cm}^3\)</div>
      <div class="option" data-option="D">D) \(56\,\text{cm}^3\)</div>
      <div class="option" data-option="E">E) \(36\,\text{cm}^3\)</div>
    </div>
  </div>

  <!-- PLAN -->
  <div class="card">
    <div class="card-title"><span class="icon">&#128204;</span> Plan resavanja</div>
    <ol class="plan-list">
      <li>Oznaciti ivice kvadra sa \(a\), \(b\), \(c\) i postaviti sistem jednacina za povrsine strana</li>
      <li>Pomnoziti sve tri jednacine da se dobije \((abc)^2\)</li>
      <li>Izracunati zapreminu \(V = abc\) korenovanem</li>
      <li>Verifikovati nalazeci pojedinacne dimenzije</li>
    </ol>
  </div>

  <!-- THEORY REFRESHER -->
  <details>
    <summary>Podsetnik iz teorije</summary>
    <div class="detail-content">
      <p><strong>Kvadar (pravougaoni paralelopiped)</strong> ima tri para paralelnih strana. Ako su ivice \(a\), \(b\), \(c\), onda:</p>
      <ul style="margin:0.5rem 0 0.5rem 1.5rem;">
        <li>Povrsine strana: \(S_1 = ab\), \(S_2 = ac\), \(S_3 = bc\)</li>
        <li>Zapremina: \(V = abc\)</li>
        <li>Povrsina omotaca: \(P = 2(ab + ac + bc)\)</li>
        <li>Dijagonala: \(d = \sqrt{a^2 + b^2 + c^2}\)</li>
      </ul>
      <p style="margin-top:0.75rem"><strong>Kljucan identitet:</strong></p>
      \[S_1 \cdot S_2 \cdot S_3 = (ab)(ac)(bc) = a^2 b^2 c^2 = (abc)^2 = V^2\]
      <p style="margin-top:0.5rem;">Odavde direktno sledi: \(V = \sqrt{S_1 \cdot S_2 \cdot S_3}\).</p>
    </div>
  </details>

  <!-- VISUAL AID -->
  <div class="card">
    <div class="card-title"><span class="icon">&#128202;</span> 3D vizualizacija kvadra</div>
    <p class="muted" style="margin-bottom:0.75rem;">Interaktivni prikaz kvadra sa dimenzijama \(a = 4\), \(b = 3\), \(c = 2\). Prevucite misem za rotaciju.</p>
    <div class="canvas-wrap">
      <canvas id="cuboid3d" width="700" height="480"></canvas>
    </div>
    <div class="canvas-controls">
      <button id="btnReset">Pocetni pogled</button>
      <button id="btnFront">Prednja strana (ab)</button>
      <button id="btnSide">Bocna strana (ac)</button>
      <button id="btnTop">Gornja strana (bc)</button>
      <button id="btnSpin" class="active">Auto-rotacija</button>
    </div>
  </div>

  <!-- STEP-BY-STEP SOLUTION -->
  <div class="card">
    <div class="card-title"><span class="icon">&#9999;&#65039;</span> Resenje korak po korak</div>

    <!-- Step 1 -->
    <div class="step">
      <div class="step-title">Korak 1: Postavljanje jednacina</div>
      <p>Neka su \(a\), \(b\) i \(c\) dimenzije (ivice) kvadra. Kvadar ima tri para naspramnih strana, a povrsine tih strana su:</p>
      \[
        ab = 12, \quad ac = 8, \quad bc = 6
      \]
    </div>

    <!-- Step 2 -->
    <div class="step">
      <div class="step-title">Korak 2: Mnozenje svih jednacina</div>
      <p>Pomnozimo sve tri jednacine:</p>
      \[
        (ab) \cdot (ac) \cdot (bc) = 12 \cdot 8 \cdot 6
      \]
      <p>Leva strana:</p>
      \[
        (ab)(ac)(bc) = a^2 b^2 c^2 = (abc)^2
      \]
      <p>Desna strana:</p>
      \[
        12 \cdot 8 \cdot 6 = 96 \cdot 6 = 576
      \]
      <p>Dakle:</p>
      \[
        (abc)^2 = 576
      \]
    </div>

    <div class="checkpoint">
      <span class="checkpoint-label">Proveri se:</span> Da li je \(12 \cdot 8 \cdot 6 = 576\)? Jeste: \(12 \cdot 8 = 96\), \(96 \cdot 6 = 576\).
    </div>

    <!-- Step 3 -->
    <div class="step">
      <div class="step-title">Korak 3: Nalazenje zapremine</div>
      <p>Zapremina kvadra je \(V = abc\). Korenujemo obe strane:</p>
      \[
        abc = \sqrt{576} = 24
      \]
      <p>Dakle:</p>
      \[
        \boxed{V = 24\,\text{cm}^3}
      \]
    </div>

    <!-- Step 4 -->
    <div class="step">
      <div class="step-title">Korak 4: Verifikacija &mdash; nalazenje pojedinacnih dimenzija</div>
      <p>Mozemo naci svaku dimenziju ponaosob. Iz \(abc = 24\):</p>
      \[
        c = \frac{abc}{ab} = \frac{24}{12} = 2\,\text{cm}
      \]
      \[
        b = \frac{abc}{ac} = \frac{24}{8} = 3\,\text{cm}
      \]
      \[
        a = \frac{abc}{bc} = \frac{24}{6} = 4\,\text{cm}
      \]
      <p><strong>Provera povrsina:</strong></p>
      \[
        ab = 4 \cdot 3 = 12 \;\checkmark, \quad ac = 4 \cdot 2 = 8 \;\checkmark, \quad bc = 3 \cdot 2 = 6 \;\checkmark
      \]
      <p><strong>Provera zapremine:</strong></p>
      \[
        V = 4 \cdot 3 \cdot 2 = 24\,\text{cm}^3 \;\checkmark
      \]
    </div>
  </div>

  <!-- KEY INSIGHT -->
  <div class="insight-box">
    <div class="card-title"><span class="icon">&#128161;</span> Kljucni uvid</div>
    <p>Trik je u tome sto <strong>proizvod tri povrsine strana</strong> daje <strong>kvadrat zapremine</strong>:</p>
    \[V = \sqrt{S_1 \cdot S_2 \cdot S_3}\]
    <p style="margin-top:0.5rem;">Ovo je univerzalna formula koja vazi za svaki kvadar. Ne moramo nalaziti pojedinacne dimenzije &mdash; dovoljno je pomnoziti povrsine i koreniti rezultat. Intuicija: svaka dimenzija se pojavljuje tacno dva puta u proizvodu \(S_1 \cdot S_2 \cdot S_3\), pa korenovanje "ponisti" dupliranje.</p>
  </div>

  <!-- FINAL ANSWER -->
  <div class="final-answer">
    <div class="label">Konacan odgovor</div>
    <div class="value">A) \(\;V = abc = \sqrt{12 \cdot 8 \cdot 6} = \sqrt{576} = 24\,\text{cm}^3\)</div>
  </div>

  <!-- COMMON PITFALLS -->
  <div class="card">
    <div class="card-title"><span class="icon">&#9888;&#65039;</span> Ceste greske</div>
    <div class="pitfall">
      <strong>Sabiranje umesto mnozenja:</strong> Neki ucenici sabiraju povrsine (\(12 + 8 + 6 = 26\)) umesto da ih pomnoze. Sabiranje daje poluzbir povrsine omotaca, ne zapreminu.
    </div>
    <div class="pitfall">
      <strong>Zaborav korenovanja:</strong> Posle mnozenja povrsina dobijamo \((abc)^2 = 576\), a ne \(abc = 576\). Zapremina je \(\sqrt{576} = 24\), ne 576.
    </div>
    <div class="pitfall">
      <strong>Mesanje sa opcijom B (96):</strong> Broj 96 je \(12 \cdot 8 = 96\), sto je samo delimican proizvod. Treba mnoziti sva tri i onda koreniti.
    </div>
    <div class="pitfall">
      <strong>Opcija C (48):</strong> Neko moze da pomnoze \(12 \cdot 8 \cdot 6 = 576\) i podeli sa neku povrsinu, npr. \(576/12 = 48\). To nema smisla &mdash; potrebno je korenovanje, ne deljenje.
    </div>
  </div>

  <!-- OPTIONAL CHALLENGE -->
  <div class="challenge-box">
    <div class="card-title"><span class="icon">&#127942;</span> Dodatni izazov</div>
    <p>Ako su povrsine strana kvadra \(2\), \(3\) i \(6\,\text{cm}^2\), kolika je dijagonala prostora tog kvadra?</p>
    <p class="muted" style="margin-top:0.5rem;font-size:0.9rem;">Savet: Prvo nadji \(a\), \(b\), \(c\) istom metodom, a zatim koristi \(d = \sqrt{a^2 + b^2 + c^2}\).</p>
  </div>

</div>

<script>
(function() {
  var canvas = document.getElementById('cuboid3d');
  if (!canvas) return;
  var ctx = canvas.getContext('2d');
  var W = canvas.width;
  var H = canvas.height;

  // Cuboid dimensions (scaled for visual clarity)
  var a = 4, b = 3, c = 2;
  var scale = 42;

  // Rotation angles
  var angleX = -0.45;
  var angleY = 0.65;
  var autoSpin = true;
  var highlightFace = null; // null, 'front', 'side', 'top'

  // Mouse drag state
  var dragging = false;
  var lastMX = 0, lastMY = 0;

  // 3D rotation helpers
  function rotateY(p, angle) {
    var cos = Math.cos(angle), sin = Math.sin(angle);
    return { x: p.x * cos - p.z * sin, y: p.y, z: p.x * sin + p.z * cos };
  }
  function rotateX(p, angle) {
    var cos = Math.cos(angle), sin = Math.sin(angle);
    return { x: p.x, y: p.y * cos - p.z * sin, z: p.y * sin + p.z * cos };
  }
  function project(p) {
    var perspective = 600;
    var factor = perspective / (perspective + p.z);
    return { x: W / 2 + p.x * factor, y: H / 2 - p.y * factor, z: p.z };
  }

  // Define the 8 vertices of the cuboid centered at origin
  function getVertices() {
    var ha = a * scale / 2, hb = b * scale / 2, hc = c * scale / 2;
    return [
      { x: -ha, y: -hb, z: -hc }, // 0: left-bottom-back
      { x:  ha, y: -hb, z: -hc }, // 1: right-bottom-back
      { x:  ha, y:  hb, z: -hc }, // 2: right-top-back
      { x: -ha, y:  hb, z: -hc }, // 3: left-top-back
      { x: -ha, y: -hb, z:  hc }, // 4: left-bottom-front
      { x:  ha, y: -hb, z:  hc }, // 5: right-bottom-front
      { x:  ha, y:  hb, z:  hc }, // 6: right-top-front
      { x: -ha, y:  hb, z:  hc }  // 7: left-top-front
    ];
  }

  // 6 faces: [vertex indices], color, label, highlightKey
  var faces = [
    { verts: [0, 1, 2, 3], color: 'rgba(96, 165, 250, 0.25)', border: '#60a5fa', label: 'ab = 12', key: 'front', labelColor: '#60a5fa' },
    { verts: [4, 5, 6, 7], color: 'rgba(96, 165, 250, 0.25)', border: '#60a5fa', label: 'ab = 12', key: 'front', labelColor: '#60a5fa' },
    { verts: [0, 4, 7, 3], color: 'rgba(167, 139, 250, 0.25)', border: '#a78bfa', label: 'ac = 8', key: 'side', labelColor: '#a78bfa' },
    { verts: [1, 5, 6, 2], color: 'rgba(167, 139, 250, 0.25)', border: '#a78bfa', label: 'ac = 8', key: 'side', labelColor: '#a78bfa' },  // Swapped label to match
    { verts: [3, 2, 6, 7], color: 'rgba(244, 114, 182, 0.25)', border: '#f472b6', label: 'bc = 6', key: 'top', labelColor: '#f472b6' },
    { verts: [0, 1, 5, 4], color: 'rgba(244, 114, 182, 0.25)', border: '#f472b6', label: 'bc = 6', key: 'top', labelColor: '#f472b6' }
  ];

  function faceNormalZ(projected) {
    // Cross product z-component to determine face orientation (front-facing or back-facing)
    var ax = projected[1].x - projected[0].x;
    var ay = projected[1].y - projected[0].y;
    var bx = projected[2].x - projected[0].x;
    var by = projected[2].y - projected[0].y;
    return ax * by - ay * bx;
  }

  function draw() {
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, W, H);

    var verts = getVertices();

    // Apply rotation
    var transformed = verts.map(function(v) {
      var r = rotateY(v, angleY);
      r = rotateX(r, angleX);
      return r;
    });

    var projected = transformed.map(project);

    // Collect faces with their average z for sorting (painter's algorithm)
    var facesToDraw = faces.map(function(face, i) {
      var avgZ = 0;
      for (var j = 0; j < face.verts.length; j++) {
        avgZ += transformed[face.verts[j]].z;
      }
      avgZ /= face.verts.length;
      return { face: face, index: i, avgZ: avgZ };
    });

    // Sort by z (draw far faces first)
    facesToDraw.sort(function(a, b) { return a.avgZ - b.avgZ; });

    // Draw faces
    facesToDraw.forEach(function(item) {
      var face = item.face;
      var pts = face.verts.map(function(vi) { return projected[vi]; });

      var nz = faceNormalZ(pts);
      if (nz > 0) return; // Back-facing, skip

      var isHighlighted = (highlightFace !== null && face.key === highlightFace);
      var baseAlpha = isHighlighted ? 0.55 : (highlightFace !== null ? 0.08 : 0.25);

      // Fill
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (var k = 1; k < pts.length; k++) {
        ctx.lineTo(pts[k].x, pts[k].y);
      }
      ctx.closePath();

      if (isHighlighted) {
        var col = face.border;
        ctx.fillStyle = col.replace(')', ', 0.55)').replace('rgb', 'rgba');
        // Fallback: just set directly
        if (face.key === 'front') ctx.fillStyle = 'rgba(96, 165, 250, 0.55)';
        else if (face.key === 'side') ctx.fillStyle = 'rgba(167, 139, 250, 0.55)';
        else ctx.fillStyle = 'rgba(244, 114, 182, 0.55)';
      } else if (highlightFace !== null) {
        ctx.fillStyle = 'rgba(30, 41, 59, 0.4)';
      } else {
        ctx.fillStyle = face.color;
      }
      ctx.fill();

      // Border
      ctx.strokeStyle = isHighlighted ? face.border : (highlightFace !== null ? '#334155' : face.border);
      ctx.lineWidth = isHighlighted ? 3 : 1.5;
      ctx.stroke();

      // Label on face
      if (!highlightFace || isHighlighted) {
        var cx = 0, cy = 0;
        for (var m = 0; m < pts.length; m++) { cx += pts[m].x; cy += pts[m].y; }
        cx /= pts.length; cy /= pts.length;
        ctx.fillStyle = isHighlighted ? '#ffffff' : face.labelColor;
        ctx.font = (isHighlighted ? 'bold 16px' : '14px') + ' Segoe UI, system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(face.label, cx, cy);
      }
    });

    // Draw edges for visibility
    var edges = [
      [0,1],[1,2],[2,3],[3,0], // back
      [4,5],[5,6],[6,7],[7,4], // front
      [0,4],[1,5],[2,6],[3,7]  // connecting
    ];

    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    edges.forEach(function(e) {
      var p1 = projected[e[0]], p2 = projected[e[1]];
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    });

    // Draw dimension labels along edges
    drawDimensionLabel(projected, transformed, 4, 5, 'a = 4', '#60a5fa', 22);
    drawDimensionLabel(projected, transformed, 5, 6, 'b = 3', '#a78bfa', 22);
    drawDimensionLabel(projected, transformed, 4, 0, 'c = 2', '#f472b6', -22);

    // Volume label at bottom
    ctx.fillStyle = '#4ade80';
    ctx.font = 'bold 18px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('V = a \u00B7 b \u00B7 c = 4 \u00B7 3 \u00B7 2 = 24 cm\u00B3', W / 2, H - 20);

    // Legend at top-left
    ctx.font = '13px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'left';
    var legendY = 25;
    var legends = [
      { color: '#60a5fa', text: 'ab = 12 cm\u00B2 (prednja/zadnja)' },
      { color: '#a78bfa', text: 'ac = 8 cm\u00B2 (leva/desna)' },
      { color: '#f472b6', text: 'bc = 6 cm\u00B2 (gornja/donja)' }
    ];
    legends.forEach(function(leg) {
      ctx.fillStyle = leg.color;
      ctx.fillRect(12, legendY - 8, 14, 14);
      ctx.fillStyle = '#e2e8f0';
      ctx.fillText(leg.text, 32, legendY + 3);
      legendY += 22;
    });
  }

  function drawDimensionLabel(projected, transformed, i1, i2, label, color, offset) {
    var p1 = projected[i1], p2 = projected[i2];
    var mx = (p1.x + p2.x) / 2;
    var my = (p1.y + p2.y) / 2;
    // Compute a normal direction for offset
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    var len = Math.sqrt(dx * dx + dy * dy);
    if (len < 1) return;
    var nx = -dy / len * offset;
    var ny = dx / len * offset;

    ctx.fillStyle = color;
    ctx.font = 'bold 14px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, mx + nx, my + ny);
  }

  // Animation loop
  var animId;
  function animate() {
    if (autoSpin && !dragging) {
      angleY += 0.005;
    }
    draw();
    animId = requestAnimationFrame(animate);
  }

  // Mouse/touch interaction
  canvas.addEventListener('mousedown', function(e) {
    dragging = true;
    lastMX = e.clientX;
    lastMY = e.clientY;
  });
  window.addEventListener('mousemove', function(e) {
    if (!dragging) return;
    var dx = e.clientX - lastMX;
    var dy = e.clientY - lastMY;
    angleY += dx * 0.008;
    angleX += dy * 0.008;
    // Clamp angleX
    angleX = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, angleX));
    lastMX = e.clientX;
    lastMY = e.clientY;
  });
  window.addEventListener('mouseup', function() { dragging = false; });

  // Touch support
  canvas.addEventListener('touchstart', function(e) {
    e.preventDefault();
    dragging = true;
    lastMX = e.touches[0].clientX;
    lastMY = e.touches[0].clientY;
  }, { passive: false });
  canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
    if (!dragging) return;
    var dx = e.touches[0].clientX - lastMX;
    var dy = e.touches[0].clientY - lastMY;
    angleY += dx * 0.008;
    angleX += dy * 0.008;
    angleX = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, angleX));
    lastMX = e.touches[0].clientX;
    lastMY = e.touches[0].clientY;
  }, { passive: false });
  canvas.addEventListener('touchend', function() { dragging = false; });

  // Button controls
  document.getElementById('btnReset').addEventListener('click', function() {
    angleX = -0.45; angleY = 0.65; highlightFace = null;
  });
  document.getElementById('btnFront').addEventListener('click', function() {
    highlightFace = (highlightFace === 'front') ? null : 'front';
    angleX = 0; angleY = 0; autoSpin = false;
    document.getElementById('btnSpin').classList.remove('active');
  });
  document.getElementById('btnSide').addEventListener('click', function() {
    highlightFace = (highlightFace === 'side') ? null : 'side';
    angleX = 0; angleY = -Math.PI / 2; autoSpin = false;
    document.getElementById('btnSpin').classList.remove('active');
  });
  document.getElementById('btnTop').addEventListener('click', function() {
    highlightFace = (highlightFace === 'top') ? null : 'top';
    angleX = -Math.PI / 2.2; angleY = 0.3; autoSpin = false;
    document.getElementById('btnSpin').classList.remove('active');
  });
  document.getElementById('btnSpin').addEventListener('click', function() {
    autoSpin = !autoSpin;
    highlightFace = null;
    this.classList.toggle('active', autoSpin);
  });

  animate();
})();
</script>

</body>
</html>
<!--BRAINSPARK_META
{"title":"Zapremina kvadra iz povrsina strana","subject":"math","unit":"solid_geometry","topic_tags":["stereometrija","kvadar","zapremina","povrsina strana","pravougaoni paralelopiped"]}
BRAINSPARK_META-->