<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Minimalan zbir rastojanja — Refleksija tačke</title>

<script type="text/info" id="logic-scratchpad">
PROBLEM:
Find the minimum sum of distances from an arbitrary point P(x,0) on the x-axis
to points A(-6, 1) and B(6, 4).

APPROACH:
Classic reflection/mirror problem. Both A and B are above the x-axis (same side).
To minimize |PA| + |PB| for P on the x-axis, we reflect one point across the x-axis.

Reflect A(-6, 1) across the x-axis → A'(-6, -1).
For any P on the x-axis: |PA| = |PA'| (reflection preserves distance to the axis).
So minimizing |PA| + |PB| = minimizing |PA'| + |PB|.

By the triangle inequality, |PA'| + |PB| >= |A'B|, with equality when P lies
on the segment A'B (i.e., A', P, B are collinear).

Compute |A'B|:
A' = (-6, -1), B = (6, 4)
Δx = 6 - (-6) = 12
Δy = 4 - (-1) = 5
|A'B| = sqrt(12² + 5²) = sqrt(144 + 25) = sqrt(169) = 13

Finding the optimal point P:
Line from A'(-6, -1) to B(6, 4):
Direction vector: (12, 5)
Parametric: x = -6 + 12t, y = -1 + 5t
Set y = 0: -1 + 5t = 0 → t = 1/5
x = -6 + 12(1/5) = -6 + 12/5 = -30/5 + 12/5 = -18/5 = -3.6

So optimal P = (-18/5, 0).

ANSWER: B) 13

Verification:
|PA| = sqrt((-18/5 - (-6))² + (0-1)²) = sqrt((12/5)² + 1) = sqrt(144/25 + 25/25) = sqrt(169/25) = 13/5
|PB| = sqrt((-18/5 - 6)² + (0-4)²) = sqrt((-48/5)² + 16) = sqrt(2304/25 + 400/25) = sqrt(2704/25) = 52/5
|PA| + |PB| = 13/5 + 52/5 = 65/5 = 13 ✓
</script>

<script>
MathJax = {
  tex: {
    inlineMath: [['\\(', '\\)'], ['$', '$']],
    displayMath: [['\\[', '\\]']]
  },
  svg: { fontCache: 'global' }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0f172a;
  color: #e2e8f0;
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  line-height: 1.7;
  padding: 20px;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 10px;
}

h1 {
  font-size: 2.2rem;
  font-weight: 800;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 8px;
}

.subtitle {
  color: #94a3b8;
  font-size: 1.05rem;
  margin-bottom: 28px;
}

.card {
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 14px;
  padding: 22px 26px;
  margin-bottom: 24px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.35);
}

.card h2 {
  color: #60a5fa;
  font-size: 1.35rem;
  margin-bottom: 14px;
}

.given-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 16px;
}

.given-item {
  background: rgba(30,41,59,0.8);
  border: 1px solid #334155;
  border-radius: 10px;
  padding: 12px 18px;
  min-width: 80px;
  text-align: center;
}

.given-item .label {
  color: #94a3b8;
  font-size: 0.85rem;
  margin-bottom: 4px;
}

.given-item .value {
  color: #e2e8f0;
  font-size: 1.1rem;
  font-weight: 600;
}

.answer-option {
  min-width: 90px;
  transition: none;
  cursor: default;
}

.plan-card {
  border-left: 3px solid #a78bfa;
}

.plan-card h2 {
  color: #a78bfa;
}

details {
  margin: 15px 0;
}

details summary {
  cursor: pointer;
  color: #60a5fa;
  font-weight: 600;
  font-size: 1.05rem;
  padding: 8px 0;
  list-style: none;
}

details summary::-webkit-details-marker { display: none; }

details summary::before {
  content: '▶ ';
  font-size: 0.8rem;
  transition: transform 0.2s;
}

details[open] summary::before {
  content: '▼ ';
}

.theory-list {
  padding-left: 0;
  list-style: none;
}

.theory-list li {
  padding: 8px 0;
  border-bottom: 1px solid rgba(51,65,85,0.5);
  color: #e2e8f0;
}

.theory-list li:last-child { border-bottom: none; }

.canvas-container {
  text-align: center;
}

canvas {
  border-radius: 12px;
  width: 100%;
  max-width: 700px;
  touch-action: none;
}

.drag-hint {
  color: #94a3b8;
  font-size: 0.85rem;
  margin-top: 8px;
  text-align: center;
}

.step-container {
  display: flex;
  gap: 16px;
  margin-bottom: 18px;
  padding: 14px 16px;
  border-radius: 10px;
  border-left: 3px solid transparent;
  transition: border-color 0.2s, background 0.2s;
  cursor: pointer;
}

.step-container:hover, .step-container.active {
  border-left-color: #4ade80;
  background: rgba(30,41,59,0.5);
}

.step-number {
  width: 32px;
  height: 32px;
  min-width: 32px;
  border-radius: 50%;
  background: linear-gradient(135deg, #60a5fa, #a78bfa);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 0.9rem;
  color: #0f172a;
  margin-top: 2px;
}

.step-content h3 {
  color: #e2e8f0;
  font-size: 1.1rem;
  margin-bottom: 6px;
}

.step-content p {
  color: #cbd5e1;
  margin-bottom: 8px;
}

.math-block {
  background: rgba(56,189,248,0.08);
  border: 1px solid rgba(56,189,248,0.15);
  border-radius: 8px;
  padding: 12px 16px;
  margin: 10px 0;
  font-family: 'Courier New', monospace;
  overflow-x: auto;
}

.note {
  color: #94a3b8;
  font-size: 0.9rem;
  font-style: italic;
  margin-top: 6px;
}

.checkpoint {
  background: rgba(96,165,250,0.08);
  border: 1px solid rgba(96,165,250,0.2);
  border-radius: 10px;
  padding: 14px 18px;
}

.checkpoint summary {
  color: #a78bfa;
  font-size: 0.95rem;
}

.insight-box {
  background: linear-gradient(135deg, rgba(96,165,250,0.15), rgba(167,139,250,0.15));
  border: 1px solid rgba(96,165,250,0.3);
  border-radius: 14px;
  padding: 24px;
  text-align: center;
  margin-bottom: 24px;
}

.insight-box h2 {
  color: #a78bfa;
  margin-bottom: 12px;
}

.insight-formula {
  font-size: 1.3rem;
  color: #e2e8f0;
  margin: 12px 0;
}

.final-answer-box {
  background: linear-gradient(135deg, rgba(52,211,153,0.12), rgba(74,222,128,0.12));
  border: 2px solid rgba(74,222,128,0.35);
  border-radius: 16px;
  padding: 28px;
  text-align: center;
  margin-bottom: 24px;
}

.final-answer-box h2 {
  color: #4ade80;
  font-size: 1.4rem;
  margin-bottom: 16px;
}

.final-answer-value {
  font-size: 2rem;
  font-weight: 800;
  color: #4ade80;
  margin-bottom: 16px;
}

.answer-options-final {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
  margin-top: 16px;
}

.answer-opt {
  padding: 10px 20px;
  border-radius: 10px;
  border: 2px solid #334155;
  background: #1e293b;
  color: #94a3b8;
  font-size: 1rem;
  font-weight: 600;
}

.answer-opt.correct {
  border-color: #4ade80;
  color: #4ade80;
  background: rgba(74,222,128,0.12);
}

.verification-note {
  margin-top: 16px;
  color: #94a3b8;
  font-size: 0.92rem;
  text-align: left;
  background: rgba(30,41,59,0.6);
  border-radius: 8px;
  padding: 14px;
}

.pitfall-card {
  border-left: 3px solid #f472b6;
}

.pitfall-card h2 {
  color: #f472b6;
}

.pitfall-list {
  list-style: none;
  padding: 0;
}

.pitfall-list li {
  padding: 8px 0;
  color: #cbd5e1;
  border-bottom: 1px solid rgba(51,65,85,0.4);
}

.pitfall-list li:last-child { border-bottom: none; }

.pitfall-list li::before {
  content: '⚠ ';
  color: #e09468;
}

.challenge-card {
  border-left: 3px solid #60a5fa;
}

@media (max-width: 700px) {
  h1 { font-size: 1.6rem; }
  .card { padding: 16px; }
  .given-grid { gap: 8px; }
  .given-item { min-width: 70px; padding: 10px 12px; }
  .step-container { flex-direction: column; gap: 10px; }
}
</style>
</head>
<body>
<div class="container">

  <!-- a. Title & Subtitle -->
  <h1>Minimalan zbir rastojanja do dve tačke</h1>
  <p class="subtitle">Analitička geometrija — refleksija tačke i optimizacija rastojanja na pravoj</p>

  <!-- b. Problem Statement -->
  <div class="card problem-statement">
    <h2>Postavka zadatka</h2>
    <p>
      Minimalan zbir rastojanja proizvoljne tačke na \(x\)-osi do tačaka
      \(A(-6,\, 1)\) i \(B(6,\, 4)\) jednak je:
    </p>

    <div class="given-grid" style="margin-bottom: 16px;">
      <div class="given-item">
        <div class="label">Tačka A</div>
        <div class="value">\((-6,\, 1)\)</div>
      </div>
      <div class="given-item">
        <div class="label">Tačka B</div>
        <div class="value">\((6,\, 4)\)</div>
      </div>
      <div class="given-item">
        <div class="label">Prava</div>
        <div class="value">\(x\)-osa</div>
      </div>
    </div>

    <div class="given-grid">
      <div class="given-item answer-option" data-option="A">
        <div class="label">(A)</div>
        <div class="value">\(\dfrac{29}{2}\)</div>
      </div>
      <div class="given-item answer-option" data-option="B">
        <div class="label">(B)</div>
        <div class="value">\(13\)</div>
      </div>
      <div class="given-item answer-option" data-option="C">
        <div class="label">(C)</div>
        <div class="value">\(\dfrac{25}{2}\)</div>
      </div>
      <div class="given-item answer-option" data-option="D">
        <div class="label">(D)</div>
        <div class="value">\(\dfrac{27}{2}\)</div>
      </div>
      <div class="given-item answer-option" data-option="E">
        <div class="label">(E)</div>
        <div class="value">\(14\)</div>
      </div>
    </div>
  </div>

  <!-- c. Plan -->
  <div class="card plan-card">
    <h2>Plan rešavanja</h2>
    <p>
      Koristićemo <strong>metod refleksije</strong> (osne simetrije). Pošto su obe tačke iznad
      \(x\)-ose, reflektovaćemo jednu od njih u odnosu na \(x\)-osu. Minimalno rastojanje
      dobijamo kada su reflektovana tačka, tražena tačka na osi i druga tačka kolinearne — što
      svodi problem na računanje dužine jedne duži.
    </p>
  </div>

  <!-- d. Theory Refresher -->
  <div class="card">
    <details>
      <summary>Ključne formule i teoreme</summary>
      <ul class="theory-list">
        <li>
          <strong>Rastojanje između dve tačke:</strong>
          \[ d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} \]
        </li>
        <li>
          <strong>Nejednakost trougla:</strong>
          Za bilo koje tri tačke \(X, Y, Z\) važi \(|XY| + |YZ| \geq |XZ|\),
          pri čemu jednakost važi kada \(Y\) leži na duži \(\overline{XZ}\).
        </li>
        <li>
          <strong>Refleksija tačke u odnosu na \(x\)-osu:</strong>
          Ako je \(A(x_0, y_0)\), onda je \(A'(x_0, -y_0)\). Za svaku tačku
          \(P\) na \(x\)-osi važi: \(|PA| = |PA'|\).
        </li>
        <li>
          <strong>Princip minimizacije refleksijom:</strong>
          Kada su tačke \(A\) i \(B\) sa iste strane prave, zbir \(|PA| + |PB|\)
          za \(P\) na pravoj je minimalan kada je \(P\) na duži između jedne tačke
          i refleksije druge.
        </li>
      </ul>
    </details>
  </div>

  <!-- e. Visual Aid / Interactive Diagram -->
  <div class="card">
    <h2>Interaktivni dijagram</h2>
    <div class="canvas-container">
      <canvas id="mainCanvas" width="700" height="500"></canvas>
      <p class="drag-hint">Prevucite tačku P duž \(x\)-ose da vidite kako se menja zbir rastojanja</p>
    </div>
  </div>

  <!-- f. Step-by-Step Solution -->
  <div class="card">
    <h2>Rešenje korak po korak</h2>

    <div class="step-container" id="step1">
      <div class="step-number">1</div>
      <div class="step-content">
        <h3>Postavimo problem</h3>
        <p>
          Neka je \(P(x, 0)\) proizvoljna tačka na \(x\)-osi. Treba da nađemo
          vrednost \(x\) za koju je zbir \(|PA| + |PB|\) minimalan.
        </p>
        <div class="math-block">
          \[ f(x) = |PA| + |PB| = \sqrt{(x+6)^2 + 1} + \sqrt{(x-6)^2 + 16} \]
        </div>
        <p class="note">
          Obe tačke \(A(-6, 1)\) i \(B(6, 4)\) imaju pozitivnu \(y\)-koordinatu — nalaze se iznad \(x\)-ose.
        </p>
      </div>
    </div>

    <div class="step-container" id="step2">
      <div class="step-number">2</div>
      <div class="step-content">
        <h3>Reflektujemo tačku A u odnosu na \(x\)-osu</h3>
        <p>
          Pošto su obe tačke sa iste strane \(x\)-ose, reflektujemo tačku \(A\) u odnosu na \(x\)-osu.
          Refleksija menja samo znak \(y\)-koordinate.
        </p>
        <div class="math-block">
          \[ A(-6,\, 1) \;\longrightarrow\; A'(-6,\, -1) \]
        </div>
        <p>
          Za svaku tačku \(P\) na \(x\)-osi važi \(|PA| = |PA'|\), jer je \(P\) na osi simetrije.
          Dakle:
        </p>
        <div class="math-block">
          \[ f(x) = |PA| + |PB| = |PA'| + |PB| \]
        </div>
      </div>
    </div>

    <details class="checkpoint">
      <summary>Proveri sebe: Koja je refleksija tačke \(B(6, 4)\) u odnosu na \(x\)-osu?</summary>
      <p style="margin-top: 8px; color: #4ade80;">
        \(B'(6, -4)\). Refleksija menja samo znak \(y\)-koordinate.
      </p>
    </details>

    <div class="step-container" id="step3">
      <div class="step-number">3</div>
      <div class="step-content">
        <h3>Primenimo nejednakost trougla</h3>
        <p>
          Po nejednakosti trougla, za tri tačke \(A'\), \(P\), \(B\) važi:
        </p>
        <div class="math-block">
          \[ |PA'| + |PB| \geq |A'B| \]
        </div>
        <p>
          Jednakost važi kada tačka \(P\) leži na duži \(\overline{A'B}\).
          Pošto tražimo minimum, minimum nastaje upravo kada su \(A'\), \(P\) i \(B\) kolinearne,
          tj. kada \(P\) leži na preseku duži \(\overline{A'B}\) sa \(x\)-osom.
        </p>
      </div>
    </div>

    <div class="step-container" id="step4">
      <div class="step-number">4</div>
      <div class="step-content">
        <h3>Izračunamo rastojanje \(|A'B|\)</h3>
        <p>
          Tačke su \(A'(-6,\, -1)\) i \(B(6,\, 4)\). Primenjujemo formulu za rastojanje:
        </p>
        <div class="math-block">
          \[ |A'B| = \sqrt{(6 - (-6))^2 + (4 - (-1))^2} \]
        </div>
        <p>Izračunamo razlike koordinata:</p>
        <div class="math-block">
          \[ \Delta x = 6 - (-6) = 12, \qquad \Delta y = 4 - (-1) = 5 \]
        </div>
        <p>Uvrstimo:</p>
        <div class="math-block">
          \[ |A'B| = \sqrt{12^2 + 5^2} = \sqrt{144 + 25} = \sqrt{169} = 13 \]
        </div>
        <p class="note">
          Ovo je poznata Pitagorina trojka: \(5, 12, 13\).
        </p>
      </div>
    </div>

    <details class="checkpoint">
      <summary>Proveri sebe: Koliki je zbir \(12^2 + 5^2\)?</summary>
      <p style="margin-top: 8px; color: #4ade80;">
        \(12^2 + 5^2 = 144 + 25 = 169 = 13^2\). Dakle, \(\sqrt{169} = 13\).
      </p>
    </details>

    <div class="step-container" id="step5">
      <div class="step-number">5</div>
      <div class="step-content">
        <h3>Odredimo optimalnu tačku \(P\)</h3>
        <p>
          Tačka \(P\) je presek duži \(\overline{A'B}\) sa \(x\)-osom. Parametrizujemo pravu
          kroz \(A'(-6, -1)\) i \(B(6, 4)\):
        </p>
        <div class="math-block">
          \[ x = -6 + 12t, \qquad y = -1 + 5t \]
        </div>
        <p>Postavimo \(y = 0\):</p>
        <div class="math-block">
          \[ -1 + 5t = 0 \;\Longrightarrow\; t = \frac{1}{5} \]
        </div>
        <p>Uvrstimo u \(x\):</p>
        <div class="math-block">
          \[ x = -6 + 12 \cdot \frac{1}{5} = -6 + \frac{12}{5} = \frac{-30 + 12}{5} = -\frac{18}{5} = -3{,}6 \]
        </div>
        <p>
          Dakle, optimalna tačka je \(P\!\left(-\dfrac{18}{5},\, 0\right)\).
        </p>
      </div>
    </div>

    <div class="step-container" id="step6">
      <div class="step-number">6</div>
      <div class="step-content">
        <h3>Verifikacija</h3>
        <p>
          Proveravamo izračunavanjem \(|PA| + |PB|\) za \(P\!\left(-\frac{18}{5},\, 0\right)\):
        </p>
        <div class="math-block">
          \[ |PA| = \sqrt{\left(-\frac{18}{5} + 6\right)^2 + 1^2} = \sqrt{\left(\frac{12}{5}\right)^2 + 1} = \sqrt{\frac{144}{25} + \frac{25}{25}} = \sqrt{\frac{169}{25}} = \frac{13}{5} \]
        </div>
        <div class="math-block">
          \[ |PB| = \sqrt{\left(-\frac{18}{5} - 6\right)^2 + 4^2} = \sqrt{\left(-\frac{48}{5}\right)^2 + 16} = \sqrt{\frac{2304}{25} + \frac{400}{25}} = \sqrt{\frac{2704}{25}} = \frac{52}{5} \]
        </div>
        <div class="math-block">
          \[ |PA| + |PB| = \frac{13}{5} + \frac{52}{5} = \frac{65}{5} = 13 \; \checkmark \]
        </div>
      </div>
    </div>

    <details class="checkpoint">
      <summary>Proveri sebe: Zašto reflektujemo tačku iznad ose, a ne ispod?</summary>
      <p style="margin-top: 8px; color: #4ade80;">
        Obe tačke su iznad \(x\)-ose (sa iste strane). Da bi duž \(\overline{A'B}\)
        presekla \(x\)-osu, \(A'\) mora biti ispod ose — to postižemo refleksijom. Kada
        bi tačke bile sa različitih strana ose, minimum bi bio prosto \(|AB|\).
      </p>
    </details>
  </div>

  <!-- g. Key Insight -->
  <div class="insight-box">
    <h2>Ključni uvid</h2>
    <p>Refleksija svodi problem optimizacije na prostu geometriju:</p>
    <div class="insight-formula">
      \[ \min_{P \in x\text{-osa}} \left(|PA| + |PB|\right) = |A'B| = \sqrt{12^2 + 5^2} = 13 \]
    </div>
    <p style="color: #94a3b8;">
      Pitagorina trojka \((5, 12, 13)\) daje čist celobrojni rezultat.
    </p>
  </div>

  <!-- h. Final Answer -->
  <div class="final-answer-box">
    <h2>Konačan odgovor</h2>
    <div class="final-answer-value">13</div>

    <div class="answer-options-final">
      <div class="answer-opt">(A) \(\frac{29}{2}\)</div>
      <div class="answer-opt correct">(B) 13</div>
      <div class="answer-opt">(C) \(\frac{25}{2}\)</div>
      <div class="answer-opt">(D) \(\frac{27}{2}\)</div>
      <div class="answer-opt">(E) 14</div>
    </div>

    <div class="verification-note">
      <strong>Provera:</strong> Za \(P\!\left(-\frac{18}{5}, 0\right)\) dobijamo
      \(|PA| = \frac{13}{5}\) i \(|PB| = \frac{52}{5}\), a zbir je
      \(\frac{13}{5} + \frac{52}{5} = \frac{65}{5} = 13\).
      Rezultat je ceo broj i odgovara Pitagorinoj trojci \((5, 12, 13)\),
      što potvrđuje tačnost.
    </div>
  </div>

  <!-- i. Common Pitfalls -->
  <div class="card pitfall-card">
    <h2>Česte greške</h2>
    <ul class="pitfall-list">
      <li>
        <strong>Refleksija pogrešne strane:</strong> Ako su obe tačke sa iste strane prave,
        morate reflektovati jednu od njih. Ako su sa različitih strana, minimum je prosto
        rastojanje \(|AB|\), bez refleksije.
      </li>
      <li>
        <strong>Greška u znaku pri refleksiji:</strong> Refleksija u odnosu na \(x\)-osu
        menja samo \(y\)-koordinatu: \((x, y) \to (x, -y)\). Čest propust je da se greškom
        promeni i \(x\)-koordinata.
      </li>
      <li>
        <strong>Pokušaj sa izvodom:</strong> Problem se može rešiti i analitički (izvod funkcije
        \(f(x)\) i izjednačavanje sa nulom), ali je to znatno komplikovanije i podložnije
        računskim greškama. Refleksija je elegantniji pristup.
      </li>
    </ul>
  </div>

  <!-- j. Optional Challenge -->
  <div class="card challenge-card">
    <h2>Dodatni izazov</h2>
    <p>
      Koliki je minimalan zbir rastojanja proizvoljne tačke na \(y\)-osi do istih tačaka
      \(A(-6, 1)\) i \(B(6, 4)\)?
    </p>
    <details>
      <summary>Nagoveštaj</summary>
      <p style="margin-top: 8px; color: #94a3b8;">
        Sada reflektujte jednu tačku u odnosu na \(y\)-osu (menja se znak \(x\)-koordinate).
        Obe tačke su sa različitih strana \(y\)-ose — razmislite da li je refleksija uopšte
        potrebna u tom slučaju.
      </p>
    </details>
  </div>

</div>

<script>
(() => {
  const canvas = document.getElementById('mainCanvas');
  const ctx = canvas.getContext('2d');

  const W = canvas.width;
  const H = canvas.height;

  // Coordinate system: center-ish, y up
  const originX = W / 2;
  const originY = H * 0.55;
  const scale = 38;

  function toCanvas(x, y) {
    return { x: originX + x * scale, y: originY - y * scale };
  }

  function fromCanvas(cx, cy) {
    return { x: (cx - originX) / scale, y: (originY - cy) / scale };
  }

  // Points
  const A = { x: -6, y: 1 };
  const B = { x: 6, y: 4 };
  const Ap = { x: -6, y: -1 }; // A' reflection

  // Draggable P on x-axis
  let P = { x: -3.6, y: 0 };
  let dragging = false;

  function dist(p1, p2) {
    return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
  }

  function drawGrid() {
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    for (let gx = -10; gx <= 10; gx++) {
      const p = toCanvas(gx, 0);
      ctx.beginPath();
      ctx.moveTo(p.x, 0);
      ctx.lineTo(p.x, H);
      ctx.stroke();
    }
    for (let gy = -6; gy <= 8; gy++) {
      const p = toCanvas(0, gy);
      ctx.beginPath();
      ctx.moveTo(0, p.y);
      ctx.lineTo(W, p.y);
      ctx.stroke();
    }
  }

  function drawAxes() {
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 2;

    // x-axis
    ctx.beginPath();
    ctx.moveTo(0, originY);
    ctx.lineTo(W, originY);
    ctx.stroke();

    // y-axis
    ctx.beginPath();
    ctx.moveTo(originX, 0);
    ctx.lineTo(originX, H);
    ctx.stroke();

    // Axis labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '13px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    for (let gx = -8; gx <= 8; gx += 2) {
      if (gx === 0) continue;
      const p = toCanvas(gx, 0);
      ctx.fillText(gx.toString(), p.x, p.y + 6);
    }
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (let gy = -4; gy <= 6; gy += 2) {
      if (gy === 0) continue;
      const p = toCanvas(0, gy);
      ctx.fillText(gy.toString(), p.x - 8, p.y);
    }

    // Origin
    ctx.textAlign = 'right';
    ctx.textBaseline = 'top';
    ctx.fillText('O', originX - 8, originY + 6);

    // Axis arrows
    ctx.fillStyle = '#94a3b8';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText('x', W - 16, originY + 16);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText('y', originX + 16, 16);
  }

  function drawDashedLine(p1, p2, color, dashPattern) {
    const c1 = toCanvas(p1.x, p1.y);
    const c2 = toCanvas(p2.x, p2.y);
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.setLineDash(dashPattern || [6, 4]);
    ctx.beginPath();
    ctx.moveTo(c1.x, c1.y);
    ctx.lineTo(c2.x, c2.y);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawLine(p1, p2, color, width) {
    const c1 = toCanvas(p1.x, p1.y);
    const c2 = toCanvas(p2.x, p2.y);
    ctx.strokeStyle = color;
    ctx.lineWidth = width || 2;
    ctx.beginPath();
    ctx.moveTo(c1.x, c1.y);
    ctx.lineTo(c2.x, c2.y);
    ctx.stroke();
  }

  function drawPoint(pt, color, label, labelOffset) {
    const c = toCanvas(pt.x, pt.y);
    const ox = (labelOffset && labelOffset.x) || 0;
    const oy = (labelOffset && labelOffset.y) || 0;

    // Glow
    const grd = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, 14);
    grd.addColorStop(0, color + '80');
    grd.addColorStop(1, color + '00');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(c.x, c.y, 14, 0, 2 * Math.PI);
    ctx.fill();

    // Dot
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(c.x, c.y, 5, 0, 2 * Math.PI);
    ctx.fill();

    // Label
    ctx.font = 'bold 14px Segoe UI, system-ui, sans-serif';
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(label, c.x + ox, c.y - 10 + oy);
  }

  function draw() {
    ctx.clearRect(0, 0, W, H);

    // Background
    ctx.fillStyle = '#0c1222';
    ctx.fillRect(0, 0, W, H);

    drawGrid();
    drawAxes();

    // Draw A'B line (the straight line through reflection)
    drawLine(Ap, B, 'rgba(74,222,128,0.35)', 2);

    // Dashed line from A to A' (reflection visualization)
    drawDashedLine(A, Ap, '#a78bfa80', [4, 4]);

    // Lines PA and PB
    drawLine(P, A, '#60a5fa', 2.5);
    drawLine(P, B, '#f472b6', 2.5);

    // Line PA' (dashed)
    drawDashedLine(P, Ap, '#60a5fa80', [6, 4]);

    // Distance labels
    const dPA = dist(P, A);
    const dPB = dist(P, B);
    const total = dPA + dPB;

    // PA label
    const midPA = toCanvas((P.x + A.x) / 2, (P.y + A.y) / 2);
    ctx.font = 'bold 12px Segoe UI, system-ui, sans-serif';
    ctx.fillStyle = '#60a5fa';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText('|PA| = ' + dPA.toFixed(2), midPA.x - 10, midPA.y - 6);

    // PB label
    const midPB = toCanvas((P.x + B.x) / 2, (P.y + B.y) / 2);
    ctx.fillStyle = '#f472b6';
    ctx.fillText('|PB| = ' + dPB.toFixed(2), midPB.x + 10, midPB.y - 6);

    // Points
    drawPoint(A, '#60a5fa', 'A(-6, 1)', { x: -20, y: -4 });
    drawPoint(B, '#f472b6', 'B(6, 4)', { x: 20, y: -4 });
    drawPoint(Ap, '#a78bfa', "A'(-6, -1)", { x: -20, y: 20 });
    drawPoint(P, '#4ade80', 'P', { x: 0, y: -4 });

    // P coordinate label
    const cP = toCanvas(P.x, P.y);
    ctx.font = '12px Segoe UI, system-ui, sans-serif';
    ctx.fillStyle = '#94a3b8';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText('(' + P.x.toFixed(1) + ', 0)', cP.x, cP.y + 16);

    // Sum display box
    const boxX = 12;
    const boxY = 12;
    const boxW = 240;
    const boxH = 70;

    ctx.fillStyle = 'rgba(30,41,59,0.92)';
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, boxW, boxH, 10);
    ctx.fill();
    ctx.stroke();

    ctx.font = 'bold 13px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#94a3b8';
    ctx.fillText('Zbir rastojanja:', boxX + 12, boxY + 12);

    ctx.font = 'bold 22px Segoe UI, system-ui, sans-serif';
    const isMin = Math.abs(total - 13) < 0.05;
    ctx.fillStyle = isMin ? '#4ade80' : '#e2e8f0';
    ctx.fillText('|PA| + |PB| = ' + total.toFixed(2), boxX + 12, boxY + 34);

    // Min label
    if (isMin) {
      ctx.font = 'bold 11px Segoe UI, system-ui, sans-serif';
      ctx.fillStyle = '#4ade80';
      ctx.textAlign = 'right';
      ctx.fillText('MINIMUM!', boxX + boxW - 12, boxY + 14);
    }

    // Legend
    const legX = W - 200;
    const legY = 12;
    ctx.fillStyle = 'rgba(30,41,59,0.92)';
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(legX, legY, 188, 90, 10);
    ctx.fill();
    ctx.stroke();

    ctx.font = '12px Segoe UI, system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';

    ctx.fillStyle = '#60a5fa';
    ctx.fillRect(legX + 10, legY + 16, 14, 3);
    ctx.fillText('PA (rastojanje)', legX + 30, legY + 18);

    ctx.fillStyle = '#f472b6';
    ctx.fillRect(legX + 10, legY + 36, 14, 3);
    ctx.fillText('PB (rastojanje)', legX + 30, legY + 38);

    ctx.fillStyle = '#4ade80';
    ctx.fillRect(legX + 10, legY + 56, 14, 3);
    ctx.fillText("A'B (minimum)", legX + 30, legY + 58);

    ctx.fillStyle = '#a78bfa';
    ctx.setLineDash([4, 3]);
    ctx.strokeStyle = '#a78bfa';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(legX + 10, legY + 78);
    ctx.lineTo(legX + 24, legY + 78);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillText("AA' (refleksija)", legX + 30, legY + 78);
  }

  // --- Interaction ---
  function getEventPos(e) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = W / rect.width;
    const scaleY = H / rect.height;
    let clientX, clientY;
    if (e.touches && e.touches.length > 0) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY
    };
  }

  function isNearP(pos) {
    const cP = toCanvas(P.x, P.y);
    return Math.hypot(pos.x - cP.x, pos.y - cP.y) < 20;
  }

  function handleStart(e) {
    e.preventDefault();
    const pos = getEventPos(e);
    if (isNearP(pos)) {
      dragging = true;
    }
  }

  function handleMove(e) {
    e.preventDefault();
    if (!dragging) return;
    const pos = getEventPos(e);
    const world = fromCanvas(pos.x, pos.y);
    P.x = Math.max(-9, Math.min(9, world.x));
    P.y = 0;
    draw();
  }

  function handleEnd(e) {
    e.preventDefault();
    dragging = false;
  }

  canvas.addEventListener('mousedown', handleStart);
  canvas.addEventListener('mousemove', handleMove);
  canvas.addEventListener('mouseup', handleEnd);
  canvas.addEventListener('mouseleave', handleEnd);
  canvas.addEventListener('touchstart', handleStart);
  canvas.addEventListener('touchmove', handleMove);
  canvas.addEventListener('touchend', handleEnd);

  // Step click highlight
  const steps = document.querySelectorAll('.step-container');
  steps.forEach(step => {
    step.addEventListener('click', () => {
      steps.forEach(s => s.classList.remove('active'));
      step.classList.add('active');
    });
  });

  draw();
})();
</script>
</body>
</html>
<!--BRAINSPARK_META
{
  "title": "Minimalan zbir rastojanja tačke na x-osi do dve tačke — refleksija",
  "subject": "math",
  "unit": "geometry",
  "topic_tags": ["refleksija tačke", "analitička geometrija", "rastojanje između tačaka", "optimizacija", "Pitagorina trojka"]
}
BRAINSPARK_META-->